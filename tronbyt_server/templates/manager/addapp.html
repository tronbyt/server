{% extends 'base.html' %}
{% block header %}
<link rel="stylesheet" href="{{ url_for('static', path='css/addapp-simple.css') }}">
<h1>{% block title %}{{ _('Add App') }}{% endblock %}</h1>
{% endblock %}
{% block content %}
<!-- Loading indicator -->
<div id="loading-indicator" class="loading-container">
  <div class="loading-spinner"></div>
  <p>{{ _('Loading apps...') }}</p>
</div>

<script>
  // Performance optimizations
  let isInitialLoad = true;
  let appItems = [];
  let filteredItems = [];
  let sortType = 'system';
  let searchFilter = '';
  let hideInstalled = false;
  let hideBroken = false;
  let isProcessing = false;

  // Debounce function to limit function calls
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // Optimized search with debouncing
  const debouncedSearch = debounce((searchId) => {
    applyFilters();
  }, 100);

  function searchApps(searchId, gridId) {
    debouncedSearch(searchId);
  }

  function toggleInstalledApps(searchId) {
    hideInstalled = document.getElementById('hide_installed_' + searchId).checked;
    applyFilters();
  }

  function toggleBrokenApps(searchId) {
    hideBroken = document.getElementById('hide_broken_' + searchId).checked;
    applyFilters();
  }

  function sortApps(searchId) {
    sortType = document.getElementById('sort_' + searchId).value;
    applyFilters();
  }

  // Optimized sorting function
  function sortItems(items, sortTypeParam = null) {
    const currentSortType = sortTypeParam || sortType;

    // Parse date function for newest sort
    const parseDate = (dateStr) => {
      if (!dateStr) return new Date(0);
      // Handle format "YYYY-MM-DD HH:MM"
      const parts = dateStr.split(' ');
      if (parts.length === 2) {
        const [datePart, timePart] = parts;
        const [year, month, day] = datePart.split('-').map(Number);
        const [hour, minute] = timePart.split(':').map(Number);
        return new Date(year, month - 1, day, hour, minute);
      }
      return new Date(dateStr);
    };

    // Create a copy to avoid mutating the original array
    const itemsCopy = [...items];
    const sortedItems = itemsCopy.sort((a, b) => {
      const nameA = a.getAttribute('data-name');
      const nameB = b.getAttribute('data-name');
      const installedA = a.getAttribute('data-installed') === 'true';
      const installedB = b.getAttribute('data-installed') === 'true';
      const dateA = a.getAttribute('data-date') || '';
      const dateB = b.getAttribute('data-date') || '';

      switch (currentSortType) {
        case 'alphabetical':
          return nameA.localeCompare(nameB);
        case 'rev-alphabetical':
          return nameB.localeCompare(nameA);
        case 'newest':
          // Convert date strings to Date objects for proper chronological sorting
          const dateA_obj = parseDate(dateA);
          const dateB_obj = parseDate(dateB);
          const dateComparison = dateB_obj.getTime() - dateA_obj.getTime();
          return dateComparison === 0 ? nameA.localeCompare(nameB) : dateComparison;
        case 'system':
        default:
          if (installedA && !installedB) return -1;
          if (!installedA && installedB) return 1;
          return nameA.localeCompare(nameB);
      }
    });


    return sortedItems;
  }

  // Function to show all items in a grid
  function showAllItems(grid) {
    const allItems = Array.from(grid.getElementsByClassName('app-item'));
    console.log(`Showing all ${allItems.length} items in grid ${grid.id}`);
    allItems.forEach(item => {
      item.style.display = 'block';
    });
  }

  // Robust filtering system that handles all combinations
  function applyFilters() {
    if (isInitialLoad || isProcessing) return;

    isProcessing = true;

    // Use requestAnimationFrame to batch DOM updates and prevent UI blocking
    requestAnimationFrame(() => {
      try {
        const grids = document.querySelectorAll('.app-grid');

        grids.forEach(grid => {
          if (!grid) return;
          const searchId = grid.id.replace('_app_grid', '_search');

          // Get current filter values
          const searchInput = document.getElementById(searchId);
          const currentSearchFilter = searchInput ? searchInput.value.toLowerCase().trim() : '';
          const currentHideInstalled = document.getElementById('hide_installed_' + searchId)?.checked || false;
          const currentHideBroken = document.getElementById('hide_broken_' + searchId)?.checked || false;
          const currentSortType = document.getElementById('sort_' + searchId)?.value || 'system';

          // Get all app items from the grid
          const allItems = Array.from(grid.getElementsByClassName('app-item'));

          // Filter items based on all criteria
          const filteredItems = allItems.filter(item => {
            const isInstalled = item.getAttribute('data-installed') === 'true';
            const isBroken = item.getAttribute('data-broken') === 'true';
            const name = item.getAttribute('data-name').toLowerCase();
            const summary = item.querySelector('p')?.textContent?.toLowerCase() || '';

            // Apply search filter (search both name and summary)
            if (currentSearchFilter && !name.includes(currentSearchFilter) && !summary.includes(currentSearchFilter)) {
              return false;
            }

            // Apply hide filters
            if (currentHideInstalled && isInstalled) return false;
            if (currentHideBroken && isBroken) return false;

            return true;
          });

          // Sort filtered items
          const sortedItems = sortItems(filteredItems, currentSortType);

          // Use requestAnimationFrame to prevent UI blocking during DOM reordering
          requestAnimationFrame(() => {
            // Batch DOM operations for better performance
            const fragment = document.createDocumentFragment();

            // Add sorted items to fragment
            sortedItems.forEach((item, index) => {
              fragment.appendChild(item);
              item.style.display = 'block';
            });

            // Append all at once to reduce reflows
            grid.appendChild(fragment);

            // Hide any remaining items that weren't in the filtered list
            allItems.forEach(item => {
              if (!sortedItems.includes(item)) {
                item.style.display = 'none';
              }
            });
          });

          // Update virtual scrolling state
          updateVirtualScrolling(grid, sortedItems, currentSearchFilter);

          // Update installed class states
          updateItemStates(allItems);
        });
      } finally {
        isProcessing = false;
      }
    });
  }

  // Update virtual scrolling based on current state
  function updateVirtualScrolling(grid, sortedItems, hasSearchFilter) {
    if (!grid._virtualScrolling) return;

    const ITEMS_PER_PAGE = grid._virtualScrolling.ITEMS_PER_PAGE;
    const shouldUseVirtualScrolling = sortedItems.length > ITEMS_PER_PAGE && !hasSearchFilter;

    if (shouldUseVirtualScrolling) {
      // Hide items beyond the first page
      sortedItems.forEach((item, index) => {
        if (index >= ITEMS_PER_PAGE) {
          item.style.display = 'none';
        }
      });

      // Update virtual scrolling state
      grid._virtualScrolling.visibleEnd = Math.min(ITEMS_PER_PAGE, sortedItems.length);
      grid._virtualScrolling.isLoading = false;
      grid._virtualScrolling.items = sortedItems;
    } else {
      // Show all items
      grid._virtualScrolling.visibleEnd = sortedItems.length;
      grid._virtualScrolling.isLoading = false;
      grid._virtualScrolling.items = sortedItems;
    }
  }

  // Update item states (installed class, etc.)
  function updateItemStates(allItems) {
    allItems.forEach(item => {
      if (!item) return;
      const isInstalled = item.getAttribute('data-installed') === 'true';
      if (isInstalled) {
        item.classList.add('installed');
      } else {
        item.classList.remove('installed');
      }
    });
  }

  // Intersection Observer for lazy loading images
  function setupLazyLoading() {
    const imageObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          if (img.dataset.src) {
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
            // Add loaded class when image loads
            img.onload = function() {
              img.classList.add('loaded');
            };
            // Also add loaded class immediately for cached images
            if (img.complete) {
              img.classList.add('loaded');
            }
            observer.unobserve(img);
          } else {
            console.warn('Image source is empty or undefined.');
          }
        }
      });
    }, {
      rootMargin: '50px 0px',
      threshold: 0.1
    });

    document.querySelectorAll('img[data-src]').forEach(img => {
      imageObserver.observe(img);
    });
  }

  // Virtual scrolling for large lists (optional optimization)
  function setupVirtualScrolling() {
    const grids = document.querySelectorAll('.app-grid');
    const ITEMS_PER_PAGE = 50; // Load 50 items at a time

    grids.forEach(grid => {
      if (!grid) return;
      const items = Array.from(grid.getElementsByClassName('app-item'));
      if (!items || items.length <= ITEMS_PER_PAGE) return; // Skip if list is small

      let visibleStart = 0;
      let visibleEnd = ITEMS_PER_PAGE;
      let isLoading = false;

      // Store reference to this grid's virtual scrolling state
      grid._virtualScrolling = {
        visibleStart,
        visibleEnd,
        isLoading,
        items,
        ITEMS_PER_PAGE
      };

      // Initially hide items beyond the first page only for system sort and large lists
      if (items && items.length > ITEMS_PER_PAGE) {
        // Check if we should apply virtual scrolling initially
        const shouldApplyVirtualScrolling = sortType === 'system' ||
          (document.getElementById('system_search') && !document.getElementById('system_search').value.trim());

        if (shouldApplyVirtualScrolling) {
          items.forEach((item, index) => {
            if (!item) return;
            if (index >= ITEMS_PER_PAGE) {
              item.style.display = 'none';
            }
          });
        }
      }

      // Function to load more items
      function loadMoreItems() {
        if (isLoading || visibleEnd >= items.length) return;

        isLoading = true;
        const nextStart = visibleEnd;
        const nextEnd = Math.min(visibleEnd + ITEMS_PER_PAGE, items.length);

        // Use requestAnimationFrame to batch DOM updates and prevent UI blocking
        requestAnimationFrame(() => {
          for (let i = nextStart; i < nextEnd; i++) {
            if (items[i]) {
              items[i].style.display = 'block';
            }
          }
          visibleEnd = nextEnd;
          isLoading = false;

          // Update the stored state
          grid._virtualScrolling.visibleEnd = visibleEnd;
          grid._virtualScrolling.isLoading = isLoading;

          // Re-observe the new last item
          updateObserver();
        });
      }

      // Function to load more items from filtered results
      function loadMoreFilteredItems() {
        if (!grid._virtualScrolling || grid._virtualScrolling.isLoading) return;

        const filteredItems = grid._virtualScrolling.items;
        const currentVisibleEnd = grid._virtualScrolling.visibleEnd;
        const ITEMS_PER_PAGE = grid._virtualScrolling.ITEMS_PER_PAGE;

        if (currentVisibleEnd >= filteredItems.length) return;

        grid._virtualScrolling.isLoading = true;
        const nextStart = currentVisibleEnd;
        const nextEnd = Math.min(currentVisibleEnd + ITEMS_PER_PAGE, filteredItems.length);

        // Use requestAnimationFrame to batch DOM updates and prevent UI blocking
        requestAnimationFrame(() => {
          for (let i = nextStart; i < nextEnd; i++) {
            if (filteredItems[i]) {
              filteredItems[i].style.display = 'block';
            }
          }
          grid._virtualScrolling.visibleEnd = nextEnd;
          grid._virtualScrolling.isLoading = false;

          // Re-observe the new last item
          updateObserver();
        });
      }

      // Function to update the observer
      function updateObserver() {
        if (visibleEnd >= items.length) {
          paginationObserver.disconnect();
          return;
        }

        // Observe the last few visible items to ensure we catch scroll events
        const observeStart = Math.max(0, visibleEnd - 3);
        const observeEnd = Math.min(visibleEnd, items.length);

        for (let i = observeStart; i < observeEnd; i++) {
          if (items[i] && items[i].style.display !== 'none') {
            paginationObserver.observe(items[i]);
          }
        }
      }

      // Set up intersection observer for pagination
      const paginationObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // Check if we have filtered items (filters are active)
            if (grid._virtualScrolling && grid._virtualScrolling.items && grid._virtualScrolling.items.length > 0) {
              loadMoreFilteredItems();
            } else {
              loadMoreItems();
            }
          }
        });
      }, {
        rootMargin: '200px 0px' // Increased margin to trigger earlier
      });

      // Also observe the grid container for scroll events
      const gridObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // Check if we're near the bottom and need to load more
            const rect = entry.boundingClientRect;
            const viewportHeight = window.innerHeight;

            // If the grid is visible and we're near the bottom, load more
            if (rect.bottom < viewportHeight + 300) {
              // Check if we have filtered items (filters are active)
              if (grid._virtualScrolling && grid._virtualScrolling.items && grid._virtualScrolling.items.length > 0) {
                loadMoreFilteredItems();
              } else {
                loadMoreItems();
              }
            }
          }
        });
      }, {
        rootMargin: '300px 0px'
      });

      // Initial setup
      updateObserver();
      gridObserver.observe(grid);

      // Also listen for scroll events as a fallback
      let scrollTimeout;
      window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          const rect = grid.getBoundingClientRect();
          const viewportHeight = window.innerHeight;

          // If grid is visible and we're near the bottom, load more
          if (rect.top < viewportHeight && rect.bottom > 0 && rect.bottom < viewportHeight + 500) {
            // Check if we have filtered items (filters are active)
            if (grid._virtualScrolling && grid._virtualScrolling.items && grid._virtualScrolling.items.length > 0) {
              loadMoreFilteredItems();
            } else {
              loadMoreItems();
            }
          }
        }, 100);
      });
    });
  }
</script>
<a class="w3-button w3-purple w3-round w3-padding" href="{{ url_for('uploadapp', device_id=device.id) }}">{{
  _('Upload .star file') }}</a>
<form method="post" id="main_form">
  <label for="name">{{ _('App Selection') }}</label>

  {% macro render_app_list(title, search_id, grid_id, app_list, show_controls=true, show_version=false, is_custom_apps=false) %}
  <div class="app-group">
    <h3 style="display: inline-block; margin-right: 10px;">{{ title }}</h3>
    {% if show_version and system_repo_info and system_repo_info.commit_hash %}
    <span style="font-size: 14px; color: #888;">
      (version: <a href="{{ system_repo_info.commit_url }}" target="_blank" style="color: #4CAF50; text-decoration: none;">{{ system_repo_info.commit_hash }}</a>)
    </span>
    {% endif %}

    {% if show_controls %}
    <!-- Filter and Sort Controls -->
    <div class="filter-sort-controls">
      <div class="filter-sort-controls-inner">

        <input type="search" id="{{ search_id }}" placeholder="{{ _('Search apps') }}"
          onkeyup="searchApps('{{ search_id }}', '{{ grid_id }}')"
          oninput="searchApps('{{ search_id }}', '{{ grid_id }}')" />

        <label class="control-label">
          <input type="checkbox" id="hide_installed_{{ search_id }}" onchange="toggleInstalledApps('{{ search_id }}')"
            class="control-checkbox">
          {{ _('Hide installed apps') }}
        </label>

        <label class="control-label">
          <input type="checkbox" id="hide_broken_{{ search_id }}" onchange="toggleBrokenApps('{{ search_id }}')"
            class="control-checkbox" checked>
          {{ _('Hide broken apps') }}
        </label>

        <label for="sort_{{ search_id }}" class="control-label">
          {{ _('Sort by:') }}
          <select id="sort_{{ search_id }}" onchange="sortApps('{{ search_id }}')">
            <option value="system" selected>{{ _('Default') }}</option>
            <option value="newest">{{ _('Newest') }}</option>
            <option value="alphabetical">{{ _('Alphabetical (A-Z)') }}</option>
            <option value="rev-alphabetical">{{ _('Alphabetical (Z-A)') }}</option>
          </select>
        </label>
      </div>
    </div>
    {% endif %}

    <div id="{{ grid_id }}" class="app-grid">
      {% for app in app_list %}
      <div class="app-item {% if app.get('broken') %}broken-app{% endif %}" data-value="{{ app['name'] }}" data-installed="{{ app.get('is_installed', false) | lower }}"
        data-date="{{ app.get('date', '') }}" data-name="{{ app['name'] }}" data-broken="{{ app.get('broken', false) | lower }}">
        {% if app.get('is_installed', false) %}
        <div class="installed-badge">{{ _('Installed') }}</div>
        {% endif %}

        <!-- Skeleton loader for images -->
        <div class="app-img">
          <div class="skeleton-loader"></div>
          {% if 'preview' in app %}
          <img data-src="{{ url_for('app_preview', filename=app['preview']) }}"
               alt="{{ app['name'] }}"
               class="lazy-image"
               {% if app.get('broken') %}style="opacity: 0.4;"{% endif %}>
          {% else %}
          <img data-src="{{ url_for('static', path='images/not_found.jpg') }}"
               alt="{{ app['name'] }}"
               class="lazy-image"
               {% if app.get('broken') %}style="opacity: 0.4;"{% endif %}>
          {% endif %}
        </div>

        <p {% if app.get('broken') %}style="opacity: 0.5;"{% endif %}>{{ app['name'] }} - {{ app['summary'] }}</p>
        {% if 'author' in app %}
        <p {% if app.get('broken') %}style="opacity: 0.5;"{% endif %}>{{ _('From') }} {{ app['author'] }}</p>
        {% endif %}
        {% if app.get('broken') %}
        <div style="background-color: #f44336; color: white; padding: 5px 10px; font-weight: bold; border-radius: 3px; font-size: 12px; text-align: center; line-height: 1.3; margin-top: 5px;">
          ❌ {{ _('BROKEN') }}<br>
          <span style="font-size: 10px; font-weight: normal;">{{ app.get('brokenReason', 'Unknown') }}</span>
        </div>
        {% endif %}
        {% if is_custom_apps %}
        <a href="{{ url_for('deleteupload', filename=app['path'].split('/')[-1], device_id=device.id) }}"
           class="delete-upload-btn"
           onclick="event.stopPropagation(); return confirm('{{ _('Delete this uploaded app?') }}');">
          🗑️ {{ _('Delete') }}
        </a>
        {% endif %}
        {% if config['PRODUCTION'] == '0' and not app.get('path', '').startswith("users/") %}
          {% if app.get('broken') %}
          <button class="unmark-broken-btn" onclick="unmarkAppAsBroken('{{ app.get('fileName', app['name']) }}', event);" style="background-color: #4CAF50; color: white; border: none; padding: 5px 10px; cursor: pointer; margin-top: 5px; font-size: 12px;">{{ _('Unmark Broken') }}</button>
          {% else %}
          <button class="mark-broken-btn" onclick="markAppAsBroken('{{ app.get('fileName', app['name']) }}', event);" style="background-color: #f44336; color: white; border: none; padding: 5px 10px; cursor: pointer; margin-top: 5px; font-size: 12px;">{{ _('Mark Broken') }}</button>
          {% endif %}
        {% endif %}
      </div>
      {% endfor %}
    </div>
  </div>
  {% endmacro %}

  {% if custom_apps_list %}
  {{ render_app_list(_('Custom Apps'), 'custom_search', 'custom_app_grid', custom_apps_list, show_controls=false, is_custom_apps=true) }}

  <hr>
  {% endif %}

  {{ render_app_list(_('System Apps'), 'system_search', 'system_app_grid', apps_list, show_version=true, is_custom_apps=false) }}

  <input type="hidden" name="name" id="selected_app">
  <br>
  <label for="uinterval">{{ _('Render Interval (minutes)') }}</label>
  <input name="uinterval" type="number" id="uinterval" min="0" value="{{ request.form['uinterval'] or 10 }}" required>
  <label for="display_time">{{ _('Display Time (seconds)') }}</label>
  <input name="display_time" type="number" id="display_time" min="0" value="{{ request.form['display_time'] or 0 }}"
    required>

  <label for="notes">{{ _('Notes') }}</label>
  <textarea name="notes" id="notes">{{ request.form['notes'] }}</textarea>

  <input type="submit" value="{{ _('Configure') }}" class="w3-button w3-green" onclick="move()"></input>
</form>


<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Hide loading indicator and show content
    setTimeout(() => {
      document.body.classList.add('content-loaded');
      isInitialLoad = false;

      // Initialize virtual scrolling first
      setupVirtualScrolling();

      // Initialize lazy loading
      setupLazyLoading();

      // Apply initial filters and sorting based on current state
      applyFilters();
    }, 100);

    // Optimized click handlers with event delegation
    document.addEventListener('click', function(e) {
      const appItem = e.target.closest('.app-item');
      if (!appItem) return;

      // Don't allow clicking on broken apps
      if (appItem.classList.contains('broken-app')) {
        return;
      }

      // Remove selection from all items
      document.querySelectorAll('.app-item').forEach(i => i.classList.remove('selected'));

      // Add selection to clicked item
      appItem.classList.add('selected');
      document.getElementById('selected_app').value = appItem.getAttribute('data-value');

      // Open the form submission in a new tab
      const form = document.getElementById('main_form');
      form.target = '_blank';
      form.submit();
      // Reset target so future submissions work normally
      form.target = '';
    });

    // Enhanced image loading with error handling
    document.addEventListener('load', function(e) {
      if (e.target.classList.contains('lazy-image')) {
        e.target.classList.add('loaded');
        const skeleton = e.target.parentElement.querySelector('.skeleton-loader');
        if (skeleton) {
          skeleton.style.display = 'none';
        }
      }
    }, true);

    document.addEventListener('error', function(e) {
      if (e.target.classList.contains('lazy-image')) {
        // Hide skeleton and show placeholder
        const skeleton = e.target.parentElement.querySelector('.skeleton-loader');
        if (skeleton) {
          skeleton.style.display = 'none';
        }
        e.target.style.display = 'none';
      }
    }, true);
  });

  // Function to mark app as broken (development mode only)
  function markAppAsBroken(appName, event) {
    // Stop the event from bubbling up to the parent div
    event.stopPropagation();
    event.preventDefault();

    if (!confirm("Mark '" + appName + "' as broken? This will add it to broken_apps.txt and prevent it from being installed.")) {
      return;
    }

    fetch("{{ url_for('mark_app_broken', app_name='PLACEHOLDER') }}".replace('PLACEHOLDER', encodeURIComponent(appName)), {
      method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        alert("App marked as broken successfully!");
        location.reload();
      } else {
        alert("Error: " + data.message);
      }
    })
    .catch(error => {
      console.error('Error:', error);
      alert("Failed to mark app as broken");
    });
  }

  // Function to unmark app as broken (development mode only)
  function unmarkAppAsBroken(appName, event) {
    // Stop the event from bubbling up to the parent div
    event.stopPropagation();
    event.preventDefault();

    if (!confirm("Unmark '" + appName + "' as broken? This will remove it from broken_apps.txt and allow it to be installed.")) {
      return;
    }

    fetch("{{ url_for('unmark_app_broken', app_name='PLACEHOLDER') }}".replace('PLACEHOLDER', encodeURIComponent(appName)), {
      method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        alert("App unmarked successfully!");
        location.reload();
      } else {
        alert("Error: " + data.message);
      }
    })
    .catch(error => {
      console.error('Error:', error);
      alert("Failed to unmark app");
    });
  }
</script>
{% endblock %}
