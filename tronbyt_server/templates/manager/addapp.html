{% extends 'base.html' %}
{% block header %}
<h1>{% block title %}{{ _('Add App') }}{% endblock %}</h1>
{% endblock %}
{% block content %}
<!-- Loading indicator -->
<div id="loading-indicator" class="loading-container">
  <div class="loading-spinner"></div>
  <p>{{ _('Loading apps...') }}</p>
</div>

<script>
  // Performance optimizations
  let isInitialLoad = true;
  let appItems = [];
  let filteredItems = [];
  let sortType = 'system';
  let searchFilter = '';
  let hideInstalled = false;
  let hideBroken = false;

  // Debounce function to limit function calls
  function debounce(func, wait) {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // Optimized search with debouncing
  const debouncedSearch = debounce((searchId) => {
    applyFilters();
  }, 150);

  function searchApps(searchId, gridId) {
    debouncedSearch(searchId);
  }

  function toggleInstalledApps(searchId) {
    hideInstalled = document.getElementById('hide_installed_' + searchId).checked;
    applyFilters();
  }

  function toggleBrokenApps(searchId) {
    hideBroken = document.getElementById('hide_broken_' + searchId).checked;
    applyFilters();
  }

  function sortApps(searchId) {
    sortType = document.getElementById('sort_' + searchId).value;
    applyFilters();
  }

  // Optimized sorting function
  function sortItems(items) {
    return items.sort((a, b) => {
      const nameA = a.getAttribute('data-name');
      const nameB = b.getAttribute('data-name');
      const installedA = a.getAttribute('data-installed') === 'true';
      const installedB = b.getAttribute('data-installed') === 'true';
      const dateA = a.getAttribute('data-date') || '';
      const dateB = b.getAttribute('data-date') || '';

      switch (sortType) {
        case 'alphabetical':
          return nameA.localeCompare(nameB);
        case 'rev-alphabetical':
          return nameB.localeCompare(nameA);
        case 'newest':
          const dateComparison = dateB.localeCompare(dateA);
          return dateComparison === 0 ? nameA.localeCompare(nameB) : dateComparison;
        case 'system':
        default:
          if (installedA && !installedB) return -1;
          if (!installedA && installedB) return 1;
          return nameA.localeCompare(nameB);
      }
    });
  }

  // Function to show all items in a grid
  function showAllItems(grid) {
    const allItems = Array.from(grid.getElementsByClassName('app-item'));
    console.log(`Showing all ${allItems.length} items in grid ${grid.id}`);
    allItems.forEach(item => {
      item.style.display = 'block';
    });
  }

  // Optimized filtering with virtual scrolling
  function applyFilters() {
    if (isInitialLoad) return;

    // Use requestAnimationFrame to batch DOM updates
    requestAnimationFrame(() => {
      const grids = document.querySelectorAll('.app-grid');
      
      grids.forEach(grid => {
        if (!grid) return;
        const searchId = grid.id.replace('_app_grid', '_search');
        
        // Get current filter values
        const searchInput = document.getElementById(searchId);
        const currentSearchFilter = searchInput ? searchInput.value.toLowerCase().trim() : '';
        const currentHideInstalled = document.getElementById('hide_installed_' + searchId)?.checked || false;
        const currentHideBroken = document.getElementById('hide_broken_' + searchId)?.checked || false;

        // Get all app items from the grid (including hidden ones)
        const allItems = Array.from(grid.getElementsByClassName('app-item'));
        
        // Debug logging
        console.log(`Grid: ${grid.id}, Search: "${currentSearchFilter}", HideInstalled: ${currentHideInstalled}, HideBroken: ${currentHideBroken}`);
        
        // If no search filter and no other filters, show all items
        if (!currentSearchFilter && !currentHideInstalled && !currentHideBroken) {
          console.log('Showing all items - no filters active');
          showAllItems(grid);
          // Reset virtual scrolling state if it exists
          if (grid._virtualScrolling) {
            grid._virtualScrolling.visibleEnd = Math.min(grid._virtualScrolling.ITEMS_PER_PAGE, allItems.length);
            grid._virtualScrolling.isLoading = false;
          }
          return;
        }
        
        // Filter items based on search and other criteria
        const visibleItems = allItems.filter(item => {
          const isInstalled = item.getAttribute('data-installed') === 'true';
          const isBroken = item.getAttribute('data-broken') === 'true';
          const name = item.getAttribute('data-name').toLowerCase();
          const summary = item.querySelector('p')?.textContent?.toLowerCase() || '';

          // Apply search filter (search both name and summary)
          if (currentSearchFilter && !name.includes(currentSearchFilter) && !summary.includes(currentSearchFilter)) {
            return false;
          }
          
          // Apply other filters
          if (currentHideInstalled && isInstalled) return false;
          if (currentHideBroken && isBroken) return false;

          return true;
        });

        // Sort visible items
        const sortedItems = sortItems(visibleItems);

        // Hide all items first
        allItems.forEach(item => {
          item.style.display = 'none';
        });

        // Show only filtered and sorted items
        sortedItems.forEach(item => {
          item.style.display = 'block';
        });

        // Update virtual scrolling state to work with filtered results
        if (grid._virtualScrolling) {
          // Reset virtual scrolling to work with filtered items
          const filteredItems = sortedItems;
          const ITEMS_PER_PAGE = grid._virtualScrolling.ITEMS_PER_PAGE;
          
          // Hide items beyond the first page of filtered results
          filteredItems.forEach((item, index) => {
            if (index >= ITEMS_PER_PAGE) {
              item.style.display = 'none';
            }
          });
          
          // Update virtual scrolling state
          grid._virtualScrolling.visibleEnd = Math.min(ITEMS_PER_PAGE, filteredItems.length);
          grid._virtualScrolling.isLoading = false;
          grid._virtualScrolling.items = filteredItems;
        }

        // Update visibility and classes
        allItems.forEach(item => {
          if (!item) return;
          const isInstalled = item.getAttribute('data-installed') === 'true';
          if (isInstalled) {
            item.classList.add('installed');
          } else {
            item.classList.remove('installed');
          }
        });
      });
    });
  }

  // Intersection Observer for lazy loading images
  function setupLazyLoading() {
    const imageObserver = new IntersectionObserver((entries, observer) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          const img = entry.target;
          if (img.dataset.src) {
            img.src = img.dataset.src;
            img.removeAttribute('data-src');
            observer.unobserve(img);
          } else {
            console.warn('Image source is empty or undefined.');
          }
        }
      });
    }, {
      rootMargin: '50px 0px',
      threshold: 0.1
    });

    document.querySelectorAll('img[data-src]').forEach(img => {
      imageObserver.observe(img);
    });
  }

  // Virtual scrolling for large lists (optional optimization)
  function setupVirtualScrolling() {
    const grids = document.querySelectorAll('.app-grid');
    const ITEMS_PER_PAGE = 50; // Load 50 items at a time
    
    grids.forEach(grid => {
      if (!grid) return;
      const items = Array.from(grid.getElementsByClassName('app-item'));
      if (!items || items.length <= ITEMS_PER_PAGE) return; // Skip if list is small
      
      let visibleStart = 0;
      let visibleEnd = ITEMS_PER_PAGE;
      let isLoading = false;
      
      // Store reference to this grid's virtual scrolling state
      grid._virtualScrolling = {
        visibleStart,
        visibleEnd,
        isLoading,
        items,
        ITEMS_PER_PAGE
      };
      
      // Initially hide items beyond the first page
      if (items && items.length) {
        items.forEach((item, index) => {
          if (!item) return;
          if (index >= ITEMS_PER_PAGE) {
            item.style.display = 'none';
          }
        });
      }
      
      // Function to load more items
      function loadMoreItems() {
        if (isLoading || visibleEnd >= items.length) return;
        
        isLoading = true;
        const nextStart = visibleEnd;
        const nextEnd = Math.min(visibleEnd + ITEMS_PER_PAGE, items.length);
        
        // Use requestAnimationFrame to batch DOM updates
        requestAnimationFrame(() => {
          for (let i = nextStart; i < nextEnd; i++) {
            if (items[i]) {
              items[i].style.display = '';
            }
          }
          visibleEnd = nextEnd;
          isLoading = false;
          
          // Update the stored state
          grid._virtualScrolling.visibleEnd = visibleEnd;
          grid._virtualScrolling.isLoading = isLoading;
          
          // Re-observe the new last item
          updateObserver();
        });
      }
      
      // Function to load more items from filtered results
      function loadMoreFilteredItems() {
        if (!grid._virtualScrolling || grid._virtualScrolling.isLoading) return;
        
        const filteredItems = grid._virtualScrolling.items;
        const currentVisibleEnd = grid._virtualScrolling.visibleEnd;
        const ITEMS_PER_PAGE = grid._virtualScrolling.ITEMS_PER_PAGE;
        
        if (currentVisibleEnd >= filteredItems.length) return;
        
        grid._virtualScrolling.isLoading = true;
        const nextStart = currentVisibleEnd;
        const nextEnd = Math.min(currentVisibleEnd + ITEMS_PER_PAGE, filteredItems.length);
        
        // Use requestAnimationFrame to batch DOM updates
        requestAnimationFrame(() => {
          for (let i = nextStart; i < nextEnd; i++) {
            if (filteredItems[i]) {
              filteredItems[i].style.display = '';
            }
          }
          grid._virtualScrolling.visibleEnd = nextEnd;
          grid._virtualScrolling.isLoading = false;
          
          // Re-observe the new last item
          updateObserver();
        });
      }
      
      // Function to update the observer
      function updateObserver() {
        if (visibleEnd >= items.length) {
          paginationObserver.disconnect();
          return;
        }
        
        // Observe the last few visible items to ensure we catch scroll events
        const observeStart = Math.max(0, visibleEnd - 3);
        const observeEnd = Math.min(visibleEnd, items.length);
        
        for (let i = observeStart; i < observeEnd; i++) {
          if (items[i] && items[i].style.display !== 'none') {
            paginationObserver.observe(items[i]);
          }
        }
      }
      
      // Set up intersection observer for pagination
      const paginationObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // Check if we have filtered items (filters are active)
            if (grid._virtualScrolling && grid._virtualScrolling.items && grid._virtualScrolling.items.length > 0) {
              loadMoreFilteredItems();
            } else {
              loadMoreItems();
            }
          }
        });
      }, {
        rootMargin: '200px 0px' // Increased margin to trigger earlier
      });
      
      // Also observe the grid container for scroll events
      const gridObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            // Check if we're near the bottom and need to load more
            const rect = entry.boundingClientRect;
            const viewportHeight = window.innerHeight;
            
            // If the grid is visible and we're near the bottom, load more
            if (rect.bottom < viewportHeight + 300) {
              // Check if we have filtered items (filters are active)
              if (grid._virtualScrolling && grid._virtualScrolling.items && grid._virtualScrolling.items.length > 0) {
                loadMoreFilteredItems();
              } else {
                loadMoreItems();
              }
            }
          }
        });
      }, {
        rootMargin: '300px 0px'
      });
      
      // Initial setup
      updateObserver();
      gridObserver.observe(grid);
      
      // Also listen for scroll events as a fallback
      let scrollTimeout;
      window.addEventListener('scroll', () => {
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          const rect = grid.getBoundingClientRect();
          const viewportHeight = window.innerHeight;
          
          // If grid is visible and we're near the bottom, load more
          if (rect.top < viewportHeight && rect.bottom > 0 && rect.bottom < viewportHeight + 500) {
            // Check if we have filtered items (filters are active)
            if (grid._virtualScrolling && grid._virtualScrolling.items && grid._virtualScrolling.items.length > 0) {
              loadMoreFilteredItems();
            } else {
              loadMoreItems();
            }
          }
        }, 100);
      });
    });
  }
</script>
<a class="w3-button w3-purple w3-round w3-padding" href="{{ url_for('manager.uploadapp', device_id=device['id']) }}">{{
  _('Upload .star file') }}</a>
<form method="post" id="main_form">
  <label for="name">{{ _('App Selection') }}</label>

  {% macro render_app_list(title, search_id, grid_id, app_list, show_controls=true, show_version=false, is_custom_apps=false) %}
  <div class="app-group">
    <h3 style="display: inline-block; margin-right: 10px;">{{ title }}</h3>
    {% if show_version and system_repo_info and system_repo_info.commit_hash %}
    <span style="font-size: 14px; color: #888;">
      (version: <a href="{{ system_repo_info.commit_url }}" target="_blank" style="color: #4CAF50; text-decoration: none;">{{ system_repo_info.commit_hash }}</a>)
    </span>
    {% endif %}

    {% if show_controls %}
    <!-- Filter and Sort Controls -->
    <div class="filter-sort-controls">
      <div class="filter-sort-controls-inner">

        <input type="search" id="{{ search_id }}" placeholder="{{ _('Search apps') }}"
          onkeyup="searchApps('{{ search_id }}', '{{ grid_id }}')" 
          oninput="searchApps('{{ search_id }}', '{{ grid_id }}')" />

        <label class="control-label">
          <input type="checkbox" id="hide_installed_{{ search_id }}" onchange="toggleInstalledApps('{{ search_id }}')"
            class="control-checkbox">
          {{ _('Hide installed apps') }}
        </label>

        <label class="control-label">
          <input type="checkbox" id="hide_broken_{{ search_id }}" onchange="toggleBrokenApps('{{ search_id }}')"
            class="control-checkbox" checked>
          {{ _('Hide broken apps') }}
        </label>

        <label for="sort_{{ search_id }}" class="control-label">
          {{ _('Sort by:') }}
          <select id="sort_{{ search_id }}" onchange="sortApps('{{ search_id }}')">
            <option value="system" selected>{{ _('Default') }}</option>
            <option value="newest">{{ _('Newest') }}</option>
            <option value="alphabetical">{{ _('Alphabetical (A-Z)') }}</option>
            <option value="rev-alphabetical">{{ _('Alphabetical (Z-A)') }}</option>
          </select>
        </label>
      </div>
    </div>
    {% endif %}

    <div id="{{ grid_id }}" class="app-grid">
      {% for app in app_list %}
      <div class="app-item {% if app.get('broken') %}broken-app{% endif %}" data-value="{{ app['name'] }}" data-installed="{{ app.get('is_installed', false) | lower }}"
        data-date="{{ app.get('date', '') }}" data-name="{{ app['name'] }}" data-broken="{{ app.get('broken', false) | lower }}">
        {% if app.get('is_installed', false) %}
        <div class="installed-badge">{{ _('Installed') }}</div>
        {% endif %}
        
        <!-- Skeleton loader for images -->
        <div class="app-img">
          <div class="skeleton-loader"></div>
          {% if 'preview' in app %}
          <img data-src="{{ url_for('manager.app_preview', filename=app['preview']) }}" 
               alt="{{ app['name'] }}" 
               class="lazy-image"
               {% if app.get('broken') %}style="opacity: 0.4;"{% endif %}>
          {% else %}
          <img data-src="{{ url_for('static', filename='images/not_found.jpg') }}" 
               alt="{{ app['name'] }}" 
               class="lazy-image"
               {% if app.get('broken') %}style="opacity: 0.4;"{% endif %}>
          {% endif %}
        </div>
        
        <p {% if app.get('broken') %}style="opacity: 0.5;"{% endif %}>{{ app['name'] }} - {{ app['summary'] }}</p>
        {% if 'author' in app %}
        <p {% if app.get('broken') %}style="opacity: 0.5;"{% endif %}>{{ _('From') }} {{ app['author'] }}</p>
        {% endif %}
        {% if app.get('broken') %}
        <div style="background-color: #f44336; color: white; padding: 5px 10px; font-weight: bold; border-radius: 3px; font-size: 12px; text-align: center; line-height: 1.3; margin-top: 5px;">
          ‚ùå {{ _('BROKEN') }}<br>
          <span style="font-size: 10px; font-weight: normal;">{{ app.get('brokenReason', 'Unknown') }}</span>
        </div>
        {% endif %}
        {% if is_custom_apps %}
        <a href="{{ url_for('manager.deleteupload', filename=app['path'].split('/')[-1], device_id=device['id']) }}"
           class="delete-upload-btn"
           onclick="event.stopPropagation(); return confirm('{{ _('Delete this uploaded app?') }}');">
          üóëÔ∏è {{ _('Delete') }}
        </a>
        {% endif %}
        {% if config['PRODUCTION'] == '0' and not app.get('path', '').startswith("users/") %}
          {% if app.get('broken') %}
          <button class="unmark-broken-btn" onclick="unmarkAppAsBroken('{{ app.get('fileName', app['name']) }}', event);" style="background-color: #4CAF50; color: white; border: none; padding: 5px 10px; cursor: pointer; margin-top: 5px; font-size: 12px;">{{ _('Unmark Broken') }}</button>
          {% else %}
          <button class="mark-broken-btn" onclick="markAppAsBroken('{{ app.get('fileName', app['name']) }}', event);" style="background-color: #f44336; color: white; border: none; padding: 5px 10px; cursor: pointer; margin-top: 5px; font-size: 12px;">{{ _('Mark Broken') }}</button>
          {% endif %}
        {% endif %}
      </div>
      {% endfor %}
    </div>
  </div>
  {% endmacro %}

  {% if custom_apps_list %}
  {{ render_app_list(_('Custom Apps'), 'custom_search', 'custom_app_grid', custom_apps_list, show_controls=false, is_custom_apps=true) }}

  <hr>
  {% endif %}

  {{ render_app_list(_('System Apps'), 'system_search', 'system_app_grid', apps_list, show_version=true, is_custom_apps=false) }}

  <input type="hidden" name="name" id="selected_app">
  <br>
  <label for="uinterval">{{ _('Render Interval (minutes)') }}</label>
  <input name="uinterval" type="number" id="uinterval" min="0" value="{{ request.form['uinterval'] or 10 }}" required>
  <label for="display_time">{{ _('Display Time (seconds)') }}</label>
  <input name="display_time" type="number" id="display_time" min="0" value="{{ request.form['display_time'] or 0 }}"
    required>

  <label for="notes">{{ _('Notes') }}</label>
  <textarea name="notes" id="notes">{{ request.form['notes'] }}</textarea>

  <input type="submit" value="{{ _('Configure') }}" class="w3-button w3-green" onclick="move()"></input>
</form>

<style>
  /* Loading indicator */
  .loading-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 40px;
    text-align: center;
  }

  .loading-spinner {
    width: 40px;
    height: 40px;
    border: 4px solid #f3f3f3;
    border-top: 4px solid #4CAF50;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 20px;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Hide loading indicator when content is loaded */
  .content-loaded .loading-container {
    display: none;
  }

  /* Skeleton loader */
  .skeleton-loader {
    width: 100%;
    aspect-ratio: 2 / 1;
    background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
    background-size: 200% 100%;
    animation: loading 1.5s infinite;
    border-radius: 4px;
    margin-bottom: 10px;
  }

  @keyframes loading {
    0% { background-position: 200% 0; }
    100% { background-position: -200% 0; }
  }

  /* Hide skeleton when image loads */
  .app-img img.loaded + .skeleton-loader {
    display: none;
  }

  /* Optimized grid layout */
  .app-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 10px;
    contain: layout style paint;
  }

  .app-item {
    border: 1px solid #d8d8d8;
    padding: 10px;
    text-align: center;
    cursor: pointer;
    position: relative;
    contain: layout style paint;
    will-change: transform;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
  }

  .app-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
  }

  .app-img {
    position: relative;
    width: 100%;
    aspect-ratio: 2 / 1;
    overflow: hidden;
    border-radius: 4px;
  }

  .lazy-image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0;
    transition: opacity 0.3s ease;
  }

  .lazy-image.loaded {
    opacity: 1;
  }

  .app-item.selected {
    border-color: #4CAF50;
    box-shadow: 0 0 0 2px #4CAF50;
  }

  .app-item.installed {
    border-color: #ffa500;
  }

  .installed-badge {
    position: absolute;
    top: 5px;
    right: 5px;
    background-color: #ff9800;
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 10px;
    font-weight: bold;
    z-index: 10;
  }

  .app-item.broken-app {
    border: 2px solid #f44336;
    background-color: rgba(244, 67, 54, 0.05);
    cursor: not-allowed;
  }

  .app-item.broken-app:hover {
    background-color: rgba(244, 67, 54, 0.1);
    transform: none;
  }

  .filter-sort-controls select {
    padding: 2px;
    border: 1px solid #ddd;
    border-radius: 3px;
  }

  .filter-sort-container {
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 5px;
  }

  .filter-sort-wrapper {
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
  }

  .filter-label {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .filter-checkbox {
    margin: 0 !important;
  }

  .filter-sort-controls {
    margin-bottom: 20px;
    padding: 15px;
    border: 1px solid #ddd;
    border-radius: 5px;
  }

  .filter-sort-controls-inner {
    display: flex;
    gap: 20px;
    align-items: center;
    flex-wrap: wrap;
  }

  .control-label {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .filter-sort-controls input[type="search"] {
    margin-bottom: 0;
    border: 1px solid #ddd;
    border-radius: 3px;
  }

  .filter-sort-controls .control-checkbox {
    margin: 0;
  }

  /* Performance optimizations */
  .app-grid {
    transform: translateZ(0); /* Force hardware acceleration */
    backface-visibility: hidden;
  }

  .app-item {
    transform: translateZ(0); /* Force hardware acceleration */
    backface-visibility: hidden;
  }

  /* Reduce paint operations during scrolling */
  .app-item img {
    transform: translateZ(0);
    will-change: transform;
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  /* Optimize text rendering */
  .app-item p {
    text-rendering: optimizeSpeed;
    font-smooth: never;
    -webkit-font-smoothing: subpixel-antialiased;
  }

  /* Use higher specificity to override global link styles without !important */
  .app-item a.delete-upload-btn {
    display: inline-block;
    background-color: #f44336;
    color: white;
    padding: 5px 10px;
    border-radius: 3px;
    text-decoration: none;
    font-size: 12px;
    font-weight: bold;
    margin-top: 8px;
    transition: background-color 0.2s;
    position: relative;
    z-index: 5;
  }

  .app-item a.delete-upload-btn:hover {
    background-color: #d32f2f;
    text-decoration: none;
    color: white;
  }

  .app-item a.delete-upload-btn:visited {
    color: white;
  }

  .app-item a.delete-upload-btn:active {
    color: white;
  }

  .app-item a.delete-upload-btn:focus {
    color: white;
    outline: 2px solid #d32f2f;
    outline-offset: 2px;
  }
</style>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    // Hide loading indicator and show content
    setTimeout(() => {
      document.body.classList.add('content-loaded');
      isInitialLoad = false;
      
      // Apply initial filters (including the default "hide broken apps" filter)
      applyFilters();
    }, 100);

    // Initialize lazy loading
    setupLazyLoading();

    // Initialize virtual scrolling for large lists
    setupVirtualScrolling();

    // Initialize filters and sorting for each list
    const searchIds = ['system_search', 'custom_search'];
    searchIds.forEach(searchId => {
      if (document.getElementById(searchId)) {
        sortApps(searchId);
      }
    });

    // Optimized click handlers with event delegation
    document.addEventListener('click', function(e) {
      const appItem = e.target.closest('.app-item');
      if (!appItem) return;

      // Don't allow clicking on broken apps
      if (appItem.classList.contains('broken-app')) {
        return;
      }

      // Remove selection from all items
      document.querySelectorAll('.app-item').forEach(i => i.classList.remove('selected'));
      
      // Add selection to clicked item
      appItem.classList.add('selected');
      document.getElementById('selected_app').value = appItem.getAttribute('data-value');
      
      // Open the form submission in a new tab
      const form = document.getElementById('main_form');
      form.target = '_blank';
      form.submit();
      // Reset target so future submissions work normally
      form.target = '';
    });

    // Enhanced image loading with error handling
    document.addEventListener('load', function(e) {
      if (e.target.classList.contains('lazy-image')) {
        e.target.classList.add('loaded');
        const skeleton = e.target.parentElement.querySelector('.skeleton-loader');
        if (skeleton) {
          skeleton.style.display = 'none';
        }
      }
    }, true);

    document.addEventListener('error', function(e) {
      if (e.target.classList.contains('lazy-image')) {
        // Hide skeleton and show placeholder
        const skeleton = e.target.parentElement.querySelector('.skeleton-loader');
        if (skeleton) {
          skeleton.style.display = 'none';
        }
        e.target.style.display = 'none';
      }
    }, true);
  });

  // Function to mark app as broken (development mode only)
  function markAppAsBroken(appName, event) {
    // Stop the event from bubbling up to the parent div
    event.stopPropagation();
    event.preventDefault();

    if (!confirm("Mark '" + appName + "' as broken? This will add it to broken_apps.txt and prevent it from being installed.")) {
      return;
    }

    fetch("{{ url_for('manager.mark_app_broken', app_name='PLACEHOLDER') }}".replace('PLACEHOLDER', encodeURIComponent(appName)), {
      method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        alert("App marked as broken successfully!");
        location.reload();
      } else {
        alert("Error: " + data.message);
      }
    })
    .catch(error => {
      console.error('Error:', error);
      alert("Failed to mark app as broken");
    });
  }

  // Function to unmark app as broken (development mode only)
  function unmarkAppAsBroken(appName, event) {
    // Stop the event from bubbling up to the parent div
    event.stopPropagation();
    event.preventDefault();

    if (!confirm("Unmark '" + appName + "' as broken? This will remove it from broken_apps.txt and allow it to be installed.")) {
      return;
    }

    fetch("{{ url_for('manager.unmark_app_broken', app_name='PLACEHOLDER') }}".replace('PLACEHOLDER', encodeURIComponent(appName)), {
      method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
      if (data.success) {
        alert("App unmarked successfully!");
        location.reload();
      } else {
        alert("Error: " + data.message);
      }
    })
    .catch(error => {
      console.error('Error:', error);
      alert("Failed to unmark app");
    });
  }
</script>
{% endblock %}
