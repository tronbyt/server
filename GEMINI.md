# GEMINI.md

## Project Overview

This project is a FastAPI application called **Tronbyt Server**, designed to manage apps on a Tronbyt device (a flashed Tidbyt) completely locally. It provides a web UI for managing apps and devices, and a local alternative to the official Tidbyt cloud services.

The application is built with Python and FastAPI, using `pdm` for dependency management and scripting. It uses a SQLite database to store user and device data, and can be run with Docker or as a bare metal installation. The server can also be configured to use Redis for caching.

The core functionality of the application is to serve WebP images to Tronbyt devices. These images are generated by rendering Pixlet apps, which are small programs written in a dialect of Python. The rendering is done by a shared library called `libpixlet.so`, which is called from the Python code using `ctypes`.

The application is structured into several modules:

*   `tronbyt_server/main.py`: The main entry point of the FastAPI application.
*   `tronbyt_server/routers/api.py`: Implements the Tidbyt v0 API.
*   `tronbyt_server/routers/auth.py`: User registration, login, and management.
*   `tronbyt_server/routers/manager.py`: The web application.
*   `tronbyt_server/db.py`: Handles all database interactions.
*   `tronbyt_server/firmware_utils.py`: Provides utilities for generating, modifying, and downloading firmware binaries.
*   `tronbyt_server/pixlet.py`: Provides an interface to the `libpixlet.so` shared library.
*   `tronbyt_server/sync.py`: Synchronization primitives.
*   `tronbyt_server/system_apps.py`: Utilities for managing the system apps repository.

## Building and Running

### Docker

The recommended way to run the application is with Docker and Docker Compose.

1.  **Build and run the development server:**

    ```sh
    docker compose -f docker-compose.dev.yaml up -d --build
    ```

2.  **Build and run the production server:**

    ```sh
    docker compose up -d
    ```

### Bare Metal

The application can also be run as a bare metal installation using Homebrew on macOS and Linux.

1.  **Install the application:**

    ```sh
    brew install tronbyt/tronbyt/tronbyt-server
    ```

2.  **Start the server:**

    ```sh
    brew services start tronbyt-server
    ```

### Testing

The project uses `pytest` for testing. To run the tests, use the following command:

```sh
pdm run -v pytest tests --doctest-modules
```

The tests require libpixlet.so. `.github/workflows/build.yml` has instructions how to install this library (see step "Install pixlet").

## Development Conventions

*   **Dependency Management:** The project uses `pdm` for dependency management. To add a new dependency, use `pdm add <dependency>`.
*   **Testing:** The project uses `pytest` for testing. All tests are located in the `tests/` directory.
*   **Internationalization:** The project uses `fastapi-babel` for internationalization. To extract new strings for translation, use `pdm run extract`. To initialize a new language, use `pdm run init --lang <language_code>`. To update the translation files, use `pdm run update`.
*   **Linting and Formatting:** The project uses `ruff` for linting and formatting. To check for errors, run `pdm run ruff check .`. To fix errors, run `pdm run ruff check . --fix`. Use `pdm run ruff format --diff --check` for formatting checks. When generating code, ensure that it complies to the Ruff default style documented at https://docs.astral.sh/ruff/configuration/. To format files or directories, use `pdm run ruff format`.
*   Use `pdm install -d` to install development dependencies.
*   Use `pdm export -o requirements.txt` to regenerate `requirements.txt`.
*   Use `pdm update -d --update-all` to update all dependencies (regenerate `requirements.txt` if this changed `pdm.lock`).
*   This project uses mypy for static type checking. Run `pdm run mypy` to run these checks.
*   The project also uses `pyright`, a static type checker explicitly designed for Python which helps to ensure code quality and catch errors early; to use it, run `pdm run pyright`.
*   Never use plain numbers like `404` for status codes. Always use the `status` constants.
