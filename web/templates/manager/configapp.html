{{ define "configapp" }}
{{ template "base" . }}
{{ end }}
{{ define "extra_css" }}<link rel="stylesheet" href="/static/css/pages/dashboard.css">{{ end }}
{{ define "title" }}{{ t .Localizer "Configuring" }} {{ .App.Name }}{{ end }}
{{ define "header" }}
<script src="/static/js/location.js"></script>
<div class="page-header">
    <h1 class="page-title">{{ t .Localizer "Configuring" }}: {{ .App.Name }}</h1>
</div>
{{ end }}
{{ define "content" }}
<div class="dashboard-container">
    <!-- Top Action Bar -->
    <!-- Top Action Bar REMOVED -->
    <!-- Config Content -->
    <div id="configContent" class="hidden mb-6">
        <div class="inset-panel bg-tertiary">
            <div class="field-label mb-2">{{ t .Localizer "Raw JSON Config" }}</div>
            <pre class="text-xs font-mono overflow-auto max-h-60" id="configContentPre"></pre>
        </div>
    </div>
    <!-- Debug Content -->
    <div id="debugContent" class="hidden mb-6">
        <div class="inset-panel bg-tertiary">
            <div class="field-label mb-2">{{ t .Localizer "Render Messages" }}</div>
            <pre class="text-xs font-mono overflow-auto max-h-60">{{ range .App.RenderMessages }}{{ . }}
{{ else }}{{ t .Localizer "No debug logs available." }}{{ end }}</pre>
        </div>
    </div>

    <!-- Preview & App Info -->
    <div class="form-section">
        <div class="flex flex-col md:flex-row gap-6 items-start">
            <div class="flex flex-col items-center gap-2">
                <div class="bg-black p-3 border border-neutral-800 rounded">
                    <img id="previewImage"
                         src="/devices/{{ .Device.ID }}/installations/{{ .App.Iname }}/preview"
                         alt="{{ t .Localizer "Preview" }}"
                         width="256"
                         height="128"
                         style="image-rendering: pixelated; display: block;">
                </div>
                <span class="text-[10px] font-mono uppercase tracking-wider opacity-50">{{ .App.Iname }}</span>
            </div>
            {{ if .AppMetadata }}
            <div class="flex-1">
                {{ if .AppMetadata.Summary }}
                <p class="font-bold mb-2">{{ .AppMetadata.Summary }}</p>
                {{ end }}
                {{ if .AppMetadata.Desc }}
                <div class="text-secondary text-sm leading-relaxed">{{ .AppMetadata.Desc }}</div>
                {{ end }}
                {{ if .AppMetadata.Author }}
                <div class="mt-3 pt-3 border-t border-neutral-300 dark:border-neutral-700 text-xs font-mono opacity-60">
                    {{ t .Localizer "Author" }}: {{ .AppMetadata.Author }}
                </div>
                {{ end }}
            </div>
            {{ end }}
        </div>
    </div>

    <form method="post" id="dynamicForm">
        <!-- Schema Config Section -->
        <div class="form-section">
            <div class="flex items-center justify-between mb-4">
                <h2 class="section-title mb-0">{{ t .Localizer "App Configuration" }}</h2>
                <div class="flex gap-2">
                    <button id="toggleConfigBtn" type="button" class="btn-secondary btn-sm">
                        <i data-lucide="file-code"></i> <span class="button-label">{{ t .Localizer "Config" }}</span>
                    </button>
                    <button id="toggleDebugBtn" type="button" class="btn-secondary btn-sm">
                        <i data-lucide="bug"></i> <span class="button-label">{{ t .Localizer "Debug" }}</span>
                    </button>
                </div>
            </div>
            <div id="schemaConfigContainer" class="form-grid">
                <!-- Schema fields will be injected here by JavaScript -->
            </div>
        </div>

        <!-- App Settings Section -->
        <div class="form-section">
            <h2 class="section-title">{{ t .Localizer "Display Settings" }}</h2>
            <div class="form-grid">
                <div class="form-field">
                    <label class="field-label" for="uinterval">{{ t .Localizer "Render Interval (Minutes)" }}</label>
                    <input type="number" name="uinterval" id="uinterval" min="0" class="field-input"
                           value="{{ .App.UInterval }}" data-default="{{ .App.UInterval }}" required>
                    <span class="field-hint">{{ t .Localizer "Update every X minutes" }}</span>
                </div>

                <div class="form-field">
                    <label class="field-label" for="display_time">{{ t .Localizer "Display Time (Seconds)" }}</label>
                    <input type="number" name="display_time" id="display_time" min="0" class="field-input"
                           value="{{ .App.DisplayTime }}" data-default="{{ .App.DisplayTime }}">
                    <span class="field-hint">{{ t .Localizer "0 for device default" }}</span>
                </div>

                <div class="form-field">
                    <label class="field-label" for="color_filter">
                        {{ t .Localizer "Color Filter" }}
                        <span class="icon-hover-info ml-1" title="{{ t .Localizer "ColorFilterTooltip" }}">
                            <i data-lucide="info" class="icon-sm text-muted"></i>
                        </span>
                    </label>
                    <select name="color_filter" id="color_filter" class="field-select field-input">
                        {{ range .ColorFilterOptions }}
                        <option value="{{ .Value }}" {{ if eq (derefOr $.App.ColorFilter "inherit") .Value }}selected{{ end }}>{{ t $.Localizer .Name }}</option>
                        {{ end }}
                    </select>
                </div>

                <div class="form-field">
                    <label class="field-label" for="notes">{{ t .Localizer "Notes" }}</label>
                    <input name="notes" id="notes" class="field-input"
                           value="{{ .App.Notes }}" data-default="{{ .App.Notes }}"
                           placeholder="{{ t .Localizer "Optional reference name" }}">
                </div>

                <div class="form-field col-span-full">
                    <div class="flex flex-wrap gap-6">
                        <div class="form-field-checkbox">
                            <label class="checkbox-label" for="enabled">
                                <input name="enabled" type="checkbox" id="enabled" {{ if .App.Enabled }}checked{{ end }}
                                       data-default="{{ if .App.Enabled }}true{{ else }}false{{ end }}">
                                <span>{{ t .Localizer "Enabled" }}</span>
                            </label>
                        </div>
                        <div class="form-field-checkbox">
                            <label class="checkbox-label" for="autopin">
                                <input name="autopin" type="checkbox" id="autopin" {{ if .App.AutoPin }}checked{{ end }}
                                       data-default="{{ if .App.AutoPin }}true{{ else }}false{{ end }}">
                                <span>{{ t .Localizer "Auto-pin successful renders" }}</span>
                            </label>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Schedule Section -->
        <div class="form-section">
            <h2 class="section-title">{{ t .Localizer "Schedule" }}</h2>
            <div class="form-grid">
                <div class="form-field">
                    <label class="field-label" for="start_time">{{ t .Localizer "Daily Start Time" }}</label>
                    <input type="time" name="start_time" id="start_time" class="field-input"
                           value="{{ deref .App.StartTime }}" data-default="{{ deref .App.StartTime }}">
                </div>
                <div class="form-field">
                    <label class="field-label" for="end_time">{{ t .Localizer "Daily End Time" }}</label>
                    <input type="time" name="end_time" id="end_time" class="field-input"
                           value="{{ deref .App.EndTime }}" data-default="{{ deref .App.EndTime }}">
                </div>
            </div>

            <!-- Legacy Schedule (Default) -->
            <div id="legacy_schedule" class="mt-6 pt-6 border-t border-neutral-200 dark:border-neutral-800">
                <label class="field-label mb-4 block">{{ t .Localizer "Active Days" }}</label>
                <div class="flex flex-wrap gap-x-6 gap-y-3">
                    {{ range $day := (slice "monday" "tuesday" "wednesday" "thursday" "friday" "saturday" "sunday") }}
                    <label class="checkbox-label">
                        <input type="checkbox" name="days" value="{{ $day }}" {{ if or (contains $.App.Days $day) (eq (len $.App.Days) 0) }}checked{{ end }}>
                        <span class="capitalize">{{ t $.Localizer $day }}</span>
                    </label>
                    {{ end }}
                </div>
                <span class="field-hint mt-3 block">{{ t .Localizer "If no days are selected, the app will run every day." }}</span>
            </div>

            <!-- Custom Recurrence Toggle -->
            <div class="form-field-checkbox mt-6">
                <label class="checkbox-label" for="use_custom_recurrence">
                    <input type="checkbox" name="use_custom_recurrence" id="use_custom_recurrence"
                           {{ if .App.UseCustomRecurrence }}checked{{ end }} onchange="toggleCustomRecurrence()">
                    <span>{{ t .Localizer "Use Custom Recurrence" }}</span>
                </label>
                <span class="field-hint ml-6">{{ t .Localizer "Enable advanced scheduling options (bi-weekly, monthly, yearly, etc.)" }}</span>
            </div>
        </div>
        <!-- Custom Recurrence Section -->
        <div id="custom_recurrence" class="form-section hidden mt-6 pt-6 border-t border-neutral-200 dark:border-neutral-800">
            <h3 class="section-title">{{ t .Localizer "Custom Recurrence" }}</h3>
            <div class="form-grid">
                <!-- Frequency -->
                <div class="form-field">
                    <label class="field-label" for="recurrence_type">{{ t .Localizer "Frequency" }}</label>
                    <select name="recurrence_type" id="recurrence_type" class="field-select field-input" onchange="toggleRecurrenceOptions()">
                        <option value="daily" {{ if eq (string .App.RecurrenceType) "daily" }}selected{{ end }}>{{ t .Localizer "Daily" }}</option>
                        <option value="weekly" {{ if eq (string .App.RecurrenceType) "weekly" }}selected{{ end }}>{{ t .Localizer "Weekly" }}</option>
                        <option value="monthly" {{ if eq (string .App.RecurrenceType) "monthly" }}selected{{ end }}>{{ t .Localizer "Monthly" }}</option>
                        <option value="yearly" {{ if eq (string .App.RecurrenceType) "yearly" }}selected{{ end }}>{{ t .Localizer "Yearly" }}</option>
                    </select>
                </div>

                <!-- Repeat Interval -->
                <div class="form-field">
                    <label class="field-label" for="recurrence_interval">{{ t .Localizer "Repeat Every" }}</label>
                    <div class="flex gap-2 items-center">
                        <input type="number" name="recurrence_interval" id="recurrence_interval" min="1" max="52"
                               class="field-input" style="width: 80px;"
                               value="{{ if .App.RecurrenceInterval }}{{ .App.RecurrenceInterval }}{{ else }}1{{ end }}">
                        <span id="interval_unit" class="text-secondary">{{ t .Localizer "days" }}</span>
                    </div>
                </div>

                <!-- Start Date -->
                <div class="form-field">
                    <label class="field-label" for="recurrence_start_date">{{ t .Localizer "Start Date" }}</label>
                    <input type="date" name="recurrence_start_date" id="recurrence_start_date" class="field-input"
                           value="{{ deref .App.RecurrenceStartDate }}">
                </div>

                <!-- End Date -->
                <div class="form-field">
                    <label class="field-label" for="recurrence_end_date">{{ t .Localizer "End Date (optional)" }}</label>
                    <input type="date" name="recurrence_end_date" id="recurrence_end_date" class="field-input"
                           value="{{ deref .App.RecurrenceEndDate }}">
                </div>
            </div>

            <!-- Weekly Options -->
            <div id="weekly_options" class="hidden mt-6 pt-4 border-t border-neutral-200 dark:border-neutral-700">
                <label class="field-label mb-4 block">{{ t .Localizer "Active Days for Weekly" }}</label>
                {{ $weekdays := index .App.RecurrencePattern "weekdays" }}
                {{ if not $weekdays }}{{ $weekdays = .App.Days }}{{ end }}
                <div class="flex flex-wrap gap-x-6 gap-y-3">
                    {{ range $day := (slice "monday" "tuesday" "wednesday" "thursday" "friday" "saturday" "sunday") }}
                    <label class="checkbox-label">
                        <input type="checkbox" name="weekdays" value="{{ $day }}" {{ if or (contains $weekdays $day) (eq (len $weekdays) 0) }}checked{{ end }}>
                        <span class="capitalize">{{ t $.Localizer $day }}</span>
                    </label>
                    {{ end }}
                </div>
            </div>

            <!-- Monthly Options -->
            <div id="monthly_options" class="hidden mt-6 pt-4 border-t border-neutral-200 dark:border-neutral-700">
                {{ $dom := index .App.RecurrencePattern "day_of_month" }}
                {{ $dow := index .App.RecurrencePattern "day_of_week" }}
                {{ $current_pattern := "day_of_month" }}
                {{ if $dow }}{{ $current_pattern = "day_of_week" }}{{ end }}

                <div class="form-grid">
                    <div class="form-field">
                        <label class="field-label" for="monthly_pattern">{{ t .Localizer "Monthly Pattern" }}</label>
                        <select name="monthly_pattern" id="monthly_pattern" class="field-select field-input" onchange="toggleMonthlyPatternOptions()">
                            <option value="day_of_month" {{ if eq $current_pattern "day_of_month" }}selected{{ end }}>{{ t .Localizer "Day of Month" }}</option>
                            <option value="day_of_week" {{ if eq $current_pattern "day_of_week" }}selected{{ end }}>{{ t .Localizer "Day of Week" }}</option>
                        </select>
                    </div>

                    <!-- Day of Month Option -->
                    <div id="day_of_month_option" class="form-field">
                        <label class="field-label" for="day_of_month">{{ t .Localizer "Day of Month" }}</label>
                        <input type="number" name="day_of_month" id="day_of_month" min="1" max="31" class="field-input"
                               value="{{ if $dom }}{{ $dom }}{{ else }}1{{ end }}" style="width: 80px;">
                        <span class="field-hint">{{ t .Localizer "Which day of the month (1-31)" }}</span>
                    </div>
                </div>

                <!-- Day of Week Option -->
                <div id="day_of_week_option" class="hidden form-grid mt-4">
                    <div class="form-field">
                        <label class="field-label">{{ t .Localizer "Day of Week Pattern" }}</label>
                        <div class="flex gap-3 items-center">
                            <select name="week_occurrence" id="week_occurrence" class="field-select field-input" onchange="updateDayOfWeekPattern()">
                                <option value="first">{{ t .Localizer "First" }}</option>
                                <option value="second">{{ t .Localizer "Second" }}</option>
                                <option value="third">{{ t .Localizer "Third" }}</option>
                                <option value="fourth">{{ t .Localizer "Fourth" }}</option>
                                <option value="last">{{ t .Localizer "Last" }}</option>
                            </select>
                            <select name="week_day" id="week_day" class="field-select field-input" onchange="updateDayOfWeekPattern()">
                                <option value="monday">{{ t .Localizer "Monday" }}</option>
                                <option value="tuesday">{{ t .Localizer "Tuesday" }}</option>
                                <option value="wednesday">{{ t .Localizer "Wednesday" }}</option>
                                <option value="thursday">{{ t .Localizer "Thursday" }}</option>
                                <option value="friday">{{ t .Localizer "Friday" }}</option>
                                <option value="saturday">{{ t .Localizer "Saturday" }}</option>
                                <option value="sunday">{{ t .Localizer "Sunday" }}</option>
                            </select>
                            <input type="hidden" name="day_of_week_pattern" id="day_of_week_pattern" value="{{ if $dow }}{{ $dow }}{{ end }}">
                        </div>
                        <span class="field-hint">{{ t .Localizer "Example: First Monday of the month" }}</span>
                    </div>
                </div>
            </div>
        </div>


        <!-- Configuration Management -->
        <div class="form-section">
             <h2 class="section-title">{{ t .Localizer "Configuration Management" }}</h2>
             <div class="flex flex-col md:flex-row gap-3">
                <div class="flex-1 p-3 border border-neutral-200 flex flex-col md:flex-row md:items-center justify-between gap-3">
                    <div class="text-sm">
                        <strong>{{ t .Localizer "Export Configuration" }}</strong>
                        <div class="text-xs text-secondary">{{ t .Localizer "Backup app settings." }}</div>
                    </div>
                     <button type="button" class="btn-secondary whitespace-nowrap justify-center" onclick="exportConfig()">
                        <i data-lucide="download"></i> {{ t .Localizer "Export" }}
                     </button>
                </div>

                <div class="flex-1 p-3 border border-neutral-200 flex flex-col md:flex-row md:items-center justify-between gap-3">
                    <div class="text-sm">
                        <strong>{{ t .Localizer "Import Configuration" }}</strong>
                        <div class="text-xs text-secondary">{{ t .Localizer "Restore app settings." }}</div>
                    </div>
                     <button type="button" class="btn-secondary whitespace-nowrap justify-center" onclick="document.getElementById('importConfigInput').click()">
                        <i data-lucide="upload"></i> {{ t .Localizer "Import" }}
                     </button>
                </div>
             </div>
        </div>

        <!-- Form Actions -->
        <div class="form-section border-t pt-6 mt-6">
            <div class="form-actions flex-col md:flex-row justify-between gap-4">
                <div class="flex flex-col md:flex-row gap-3 w-full md:w-auto">
                    <button type="submit" class="btn-primary w-full md:w-auto justify-center">
                        <i data-lucide="save"></i> {{ t .Localizer "Save Changes" }}
                    </button>
                    {{ if eq .Device.Info.ProtocolType "WS" }}
                    <button type="button" class="btn-secondary w-full md:w-auto justify-center" id="previewButton">
                        <i data-lucide="eye"></i> {{ t .Localizer "Preview" }}
                    </button>
                    {{ end }}
                    <button type="button" class="btn-secondary w-full md:w-auto justify-center" id="resetButton">
                        <i data-lucide="rotate-ccw"></i> {{ t .Localizer "Reset" }}
                    </button>
                </div>
                <div class="flex flex-col md:flex-row gap-3 w-full md:w-auto">
                    <button type="button" class="btn-secondary w-full md:w-auto justify-center" id="cancelButton">
                        <i data-lucide="x-circle"></i> {{ t .Localizer "Cancel" }}
                    </button>
                    <button type="button" class="btn-delete w-full md:w-auto justify-center" id="deleteButton"
                            onclick="if(confirm('{{ t .Localizer "Delete App?" }}')) deleteApp('{{ .Device.ID }}', '{{ .App.Iname }}', true)">
                        <i data-lucide="trash-2"></i> {{ t .Localizer "Delete App" }}
                    </button>
                </div>
            </div>
        </div>

        <!-- API Usage (Collapsible) -->
        <div class="form-section" id="apiUsageSection">
            <div class="flex items-center gap-3 mb-4">
                <h2 class="section-title mb-0">{{ t .Localizer "API Usage" }}</h2>
                <button id="toggleApiUsageBtn" type="button" class="btn-secondary text-sm">
                    <i data-lucide="code"></i> <span class="button-label">{{ t .Localizer "Show" }}</span>
                </button>
            </div>
            <div class="api-usage-details hidden">
                <div class="inset-panel bg-tertiary">
                    <p class="text-secondary mb-4">{{ t .Localizer "Use these curl commands to control this app via the API:" }}</p>
                    <!-- Enable App -->
                    <div class="mb-6">
                        <h4 class="field-label mb-2">{{ t .Localizer "Enable App" }}</h4>
                        <pre class="text-xs font-mono overflow-auto">curl -X PATCH \
  -H "Authorization: Bearer {{ .Device.APIKey }}" \
  -H "Content-Type: application/json" \
  -d '{"enabled": true}' \
  /v0/devices/{{ .Device.ID }}/installations/{{ .App.Iname }}</pre>
                    </div>
                    <!-- Disable App -->
                    <div class="mb-6">
                        <h4 class="field-label mb-2 text-danger">{{ t .Localizer "Disable App" }}</h4>
                        <pre class="text-xs font-mono overflow-auto">curl -X PATCH \
  -H "Authorization: Bearer {{ .Device.APIKey }}" \
  -H "Content-Type: application/json" \
  -d '{"enabled": false}' \
  /v0/devices/{{ .Device.ID }}/installations/{{ .App.Iname }}</pre>
                    </div>
                    <!-- Pin App -->
                    <div class="mb-6">
                        <h4 class="field-label mb-2">{{ t .Localizer "Pin App" }}</h4>
                        <pre class="text-xs font-mono overflow-auto">curl -X PATCH \
  -H "Authorization: Bearer {{ .Device.APIKey }}" \
  -H "Content-Type: application/json" \
  -d '{"pinnedApp": "{{ .App.Iname }}"}' \
  /v0/devices/{{ .Device.ID }}</pre>
                    </div>
                    <!-- Unpin App -->
                    <div class="mb-4">
                        <h4 class="field-label mb-2 text-danger">{{ t .Localizer "Unpin App" }}</h4>
                        <pre class="text-xs font-mono overflow-auto">curl -X PATCH \
  -H "Authorization: Bearer {{ .Device.APIKey }}" \
  -H "Content-Type: application/json" \
  -d '{"pinnedApp": ""}' \
  /v0/devices/{{ .Device.ID }}</pre>
                    </div>
                    <p class="text-xs text-muted">
                        <strong>{{ t .Localizer "Note:" }}</strong> {{ t .Localizer "Replace YOUR_API_KEY with your device API key if not using the one shown above." }}
                    </p>
                </div>
            </div>
        </div>
</div><!-- end dashboard-container -->

<script>
  // Make the schema and config objects available to JavaScript
  const schema = {{ .Schema }};
  const config = {{ .AppConfig | json }} || {};
  const deleteOnCancel = {{ .DeleteOnCancel }};

  // Device Location
  const deviceLocation = {{ if .Device.Location }}{{ json .Device.Location }}{{ else }}null{{ end }};

  // Initialize toggle buttons for config and debug content
  function initializeToggleButtons() {
    const toggleConfigBtn = document.getElementById("toggleConfigBtn");
    const configContent = document.getElementById("configContent");
    const toggleDebugBtn = document.getElementById("toggleDebugBtn");
    const debugContent = document.getElementById("debugContent");

    if (toggleConfigBtn && configContent) {
      toggleConfigBtn.addEventListener("click", function () {
        toggleContent(configContent, toggleConfigBtn,
          "{{ t .Localizer "Hide App Config" }}", "{{ t .Localizer "Show App Config" }}", 'hidden');
      });
    }

    if (toggleDebugBtn && debugContent) {
      toggleDebugBtn.addEventListener("click", function () {
        toggleContent(debugContent, toggleDebugBtn,
          "{{ t .Localizer "Hide Render Debug" }}", "{{ t .Localizer "Show Render Debug" }}", 'hidden');
      });
    }

    const toggleApiUsageBtn = document.getElementById("toggleApiUsageBtn");
    const apiUsageDetails = document.querySelector("#apiUsageSection .api-usage-details");

    if (toggleApiUsageBtn && apiUsageDetails) {
      // Set initial button text based on initial hidden state
      const label = toggleApiUsageBtn.querySelector(".button-label");
      if (apiUsageDetails.classList.contains("hidden")) {
        label.textContent = "{{ t .Localizer "Show" }}";
      } else {
        label.textContent = "{{ t .Localizer "Hide" }}";
      }

      toggleApiUsageBtn.addEventListener("click", function () {
        toggleContent(apiUsageDetails, toggleApiUsageBtn,
          "{{ t .Localizer "Hide" }}", "{{ t .Localizer "Show" }}", 'hidden');
      });
    }
  }

  // Generic function to toggle content visibility
  function toggleContent(content, button, hideText, showText, className) {
    const label = button.querySelector(".button-label");
    const target = label || button;
    if (content.classList.contains(className)) {
      content.classList.remove(className);
      target.textContent = hideText;
    } else {
      content.classList.add(className);
      target.textContent = showText;
    }
  }

  function debounce(func, wait) {
    let timeout;
    return function (...args) {
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        func.apply(this, args);
      }, wait);
    };
  }

  // Function to update the config text and preview image
  const updateConfigAndPreview = debounce(() => {
    const configContentPre = document.getElementById("configContentPre");
    const previewImage = document.getElementById("previewImage");
    if (configContentPre) configContentPre.textContent = JSON.stringify(config, null, 2);

    // Trigger backend preview (POST to update ephemeral, then GET with config param)
    previewApp('{{ .Device.ID }}', '{{ .App.Iname }}', config, null, null)
    .then(() => {
         // Refresh image with cache busting AND pass current config as query param
         if(previewImage) {
             const currentSrc = previewImage.src.split('?')[0];
             const encodedConfig = encodeURIComponent(JSON.stringify(config));
             previewImage.src = `${currentSrc}?config=${encodedConfig}&t=${new Date().getTime()}`;
             // Note: The 'load' event listener below will handle hiding the skeleton
             // when the new image is actually loaded.
             previewImage.classList.remove('loaded'); // Reset to show skeleton during load
         }
    });
  }, 500);

  // Centralized config update handler
  function handleConfigUpdate(event) {
    const target = event.target;
    // We expect dataset.configId for schema fields
    const configId = target.dataset.configId;

    if (!configId) {
        // Not a schema config field
        return;
    }

    if (target.hasAttribute("data-ignore-config")) {
      return;
    }
    if (target.type === "checkbox") {
      config[configId] = target.checked ? "true" : "false";
    } else if (target.type === "select-one") {
      config[configId] = target.value;
    } else if (target.type === "color") {
      config[configId] = target.value;
    } else if (target.type === "datetime-local") {
      config[configId] = new Date(target.value).toISOString();
    } else {
      config[configId] = target.value;
    }
    updateConfigAndPreview();
  }

  function createFormFields(schema, config) {
    const fields = [];
    if (!schema || !schema.schema) return fields;

    schema.schema.forEach(field => {
      if (field.type === "generated") return;

      const fieldDiv = document.createElement("div");
      fieldDiv.className = "form-field";

      // Label
      const label = document.createElement("label");
      const inputId = "schema_" + field.id;
      label.htmlFor = inputId;
      label.className = "field-label";
      label.appendChild(document.createTextNode(field.name));
      fieldDiv.appendChild(label);

      // Input
      let inputElement;

      switch (field.type) {
        case "text":
          inputElement = document.createElement("input");
          inputElement.type = field.secret ? "password" : "text";
          inputElement.value = config[field.id] || field.default || "";
          inputElement.className = "field-input";
          break;
        case "color":
          inputElement = document.createElement("input");
          inputElement.type = "color";
          inputElement.value = config[field.id] || field.default || "#000000";
          inputElement.className = "field-input";
          inputElement.style.width = "60px";
          inputElement.style.height = "2.5rem";
          if (field.palette) {
              const div = createColorPaletteButtons(field, inputElement);
              fieldDiv.appendChild(div);
          }
          break;
        case "onoff":
          // Create checkbox with design system styling
          const checkboxWrapper = document.createElement("div");
          checkboxWrapper.className = "form-field-checkbox";
          const checkboxLabel = document.createElement("label");
          checkboxLabel.className = "checkbox-label";
          inputElement = document.createElement("input");
          inputElement.type = "checkbox";
          const val = config[field.id];
          const isChecked = val === "true" || val === true || (!val && field.default === "true");
          inputElement.checked = isChecked;
          config[field.id] = isChecked ? "true" : "false";
          checkboxLabel.appendChild(inputElement);
          const labelSpan = document.createElement("span");
          labelSpan.textContent = field.name;
          checkboxLabel.appendChild(labelSpan);
          checkboxWrapper.appendChild(checkboxLabel);
          // Replace regular label with checkbox wrapper structure
          fieldDiv.innerHTML = "";
          fieldDiv.appendChild(checkboxWrapper);
          inputElement.id = inputId;
          inputElement.dataset.configId = field.id;
          inputElement.addEventListener('change', handleConfigUpdate);
          fields.push(fieldDiv);
          return; // Skip normal append logic
        case "datetime":
          inputElement = document.createElement("input");
          inputElement.type = "datetime-local";
          inputElement.value = (config[field.id] || field.default || "").replace("Z", "");
          inputElement.className = "field-input";
          if (!config[field.id] && field.default) {
            config[field.id] = field.default;
          }
          break;
        case "dropdown":
          inputElement = document.createElement("select");
          inputElement.className = "field-select field-input";
          if (field.options) {
            field.options.forEach(opt => {
               const o = document.createElement("option");
               o.value = opt.value;
               o.textContent = opt.display;
               if (config[field.id] === opt.value) o.selected = true;
               inputElement.appendChild(o);
            });
          }
          if (!config[field.id] && field.default) {
              inputElement.value = field.default;
              config[field.id] = field.default;
          }
          break;
        case "location":
          inputElement = createLocationField(field, config);
          break;
        case "locationbased":
          inputElement = createLocationBasedField(field, config);
          break;
        case "png":
          inputElement = createImageUploadField(field, config);
          break;
        case "typeahead":
          inputElement = createTypeaheadField(field, config);
          break;
        default:
          inputElement = document.createElement("input");
          inputElement.value = config[field.id] || "";
          inputElement.className = "field-input";
      }

      if (inputElement) {
          inputElement.id = inputId;
          inputElement.dataset.configId = field.id;
          const eventType = (inputElement.type === 'checkbox' || inputElement.tagName === 'SELECT') ? 'change' : 'input';

          if (!inputElement.hasAttribute("data-ignore-config")) {
             inputElement.addEventListener(eventType, handleConfigUpdate);
          }

          let elementToAppend = inputElement;

          if (field.type === "text" && field.secret) {
              const secretContainer = document.createElement("div");
              secretContainer.className = "flex gap-2 items-center";

              const toggleButton = document.createElement("button");
              toggleButton.type = "button";
              toggleButton.className = "btn-secondary";
              toggleButton.innerHTML = '<i data-lucide="eye"></i>';

              toggleButton.addEventListener("click", () => {
                  inputElement.type = inputElement.type === "password" ? "text" : "password";
                  toggleButton.innerHTML = inputElement.type === "password" ? '<i data-lucide="eye-off"></i>' : '<i data-lucide="eye"></i>';
                  if (typeof lucide !== 'undefined') lucide.createIcons();
              });

              secretContainer.appendChild(inputElement);
              secretContainer.appendChild(toggleButton);
              elementToAppend = secretContainer;
          }

          fieldDiv.appendChild(elementToAppend);

          // Add description/hint if present
          if (field.description) {
              const hint = document.createElement("span");
              hint.className = "field-hint";
              hint.textContent = field.description;
              fieldDiv.appendChild(hint);
          }
      }
      fields.push(fieldDiv);
    });
    return fields;
  }


  function createGeneratedFormFields(schema, config) {
    if (!schema || !schema.schema) {
      return;
    }

    schema.schema
      .filter(field => field.type === "generated")
      .forEach(field => createGeneratedField(field, config));
  }

  function createLocationSearchElements(field, config) {
    const container = document.createElement("div");

    const searchInput = document.createElement("input");
    searchInput.type = "text";
    searchInput.id = `${field.id}_search`;
    searchInput.placeholder = "{{ t .Localizer "Enter a location" }}";
    searchInput.setAttribute("data-ignore-config", "true");
    searchInput.className = "field-input";

    container.appendChild(searchInput);

    const resultsList = document.createElement("ul");
    resultsList.id = `${field.id}_results`;
    resultsList.style.listStyleType = "none";
    resultsList.style.padding = "0";
    container.appendChild(resultsList);

    return { container, searchInput, resultsList };
  }

  function createLocationField(field, config) {
    const { container, searchInput, resultsList } = createLocationSearchElements(field);

    let initialLocationJsonString = config[field.id] || (deviceLocation !== null ? JSON.stringify(deviceLocation) : undefined) || field.default || "{}";
    if (typeof initialLocationJsonString !== 'string') {
      initialLocationJsonString = JSON.stringify(initialLocationJsonString);
    }

    try {
      const parsedLoc = JSON.parse(initialLocationJsonString);
      if (parsedLoc && parsedLoc.description) {
        searchInput.value = parsedLoc.description;
      } else {
        searchInput.value = "";
      }
    } catch (e) {
      console.warn("Could not parse initial location", e);
      searchInput.value = "";
    }

    const hiddenInput = document.createElement("input");
    hiddenInput.type = "hidden";
    hiddenInput.id = "schema_" + field.id;
    hiddenInput.dataset.configId = field.id;
    hiddenInput.name = field.id;
    hiddenInput.value = initialLocationJsonString;
    container.appendChild(hiddenInput);

    enableLocationSearch(searchInput, resultsList, hiddenInput, location => {
      // location is a JSON string
      try {
          config[field.id] = JSON.parse(location);
      } catch (e) {
          config[field.id] = location;
      }
      updateConfigAndPreview();
    });

    return container;
  }

  function createLocationBasedField(field, config) {
    const { container, searchInput, resultsList } = createLocationSearchElements(field);

    if (deviceLocation) {
        if (deviceLocation.description) {
            searchInput.value = deviceLocation.description;
        }
    } else {
        searchInput.value = "";
    }

    const hiddenInput = document.createElement("input");
    hiddenInput.type = "hidden";
    hiddenInput.id = `${field.id}_location`;
    hiddenInput.name = `${field.id}_location`;
    hiddenInput.value = JSON.stringify(deviceLocation);
    hiddenInput.setAttribute("data-ignore-config", "true");
    container.appendChild(hiddenInput);

    const dropdown = document.createElement("select");
    dropdown.id = "schema_" + field.id;
    dropdown.dataset.configId = field.id;
    dropdown.name = field.id;
    dropdown.className = "field-select field-input";
    container.appendChild(dropdown);

    dropdown.addEventListener("change", handleConfigUpdate);

    enableLocationSearch(searchInput, resultsList, hiddenInput, async locationQueryJson => {
      const currentOptionJsonString = JSON.stringify(config[field.id]);
      await fetchOptionsForLocation(field, locationQueryJson, dropdown, currentOptionJsonString);
    });

    if (deviceLocation) {
      const currentOptionJsonString = JSON.stringify(config[field.id]);
      fetchOptionsForLocation(field, JSON.stringify(deviceLocation), dropdown, currentOptionJsonString);
    }

    return container;
  }

  function createImageUploadField(field, config) {
    const container = document.createElement("div");

    const uploadLabel = document.createElement("label");
    uploadLabel.htmlFor = `${field.id}_upload`;
    uploadLabel.textContent = "{{ t .Localizer "Upload Image" }}";
    container.appendChild(uploadLabel);

    const uploadInput = document.createElement("input");
    uploadInput.type = "file";
    uploadInput.id = `${field.id}_upload`;
    uploadInput.setAttribute("data-ignore-config", "true");
    uploadInput.accept = "image/png, image/jpeg, image/gif, image/svg+xml, image/webp";
    container.appendChild(uploadInput);

    const hiddenInput = document.createElement("input");
    hiddenInput.type = "hidden";
    hiddenInput.id = "schema_" + field.id;
    hiddenInput.dataset.configId = field.id;
    hiddenInput.name = field.id;
    hiddenInput.value = config[field.id] || "";
    container.appendChild(hiddenInput);

    const previewImage = document.createElement("img");
    previewImage.id = `${field.id}_preview`;
    previewImage.src = config[field.id] ? `data:image/png;base64,${config[field.id]}` : "";
    previewImage.alt = "{{ t .Localizer "Preview" }}";
    previewImage.style.maxWidth = "100%";
    previewImage.style.height = "auto";
    previewImage.style.marginTop = "10px";
    previewImage.style.display = config[field.id] ? "inline" : "none";
    container.appendChild(previewImage);

    uploadInput.addEventListener("change", event => {
      const file = event.target.files[0];
      if (!file) return;

      const maxSize = 500 * 1024;
      if (file.size > maxSize) {
        alert("{{ t .Localizer "File size exceeds 500KB limit. Please upload a smaller image." }}");
        uploadInput.value = "";
        return;
      }

      const reader = new FileReader();
      reader.onload = e => {
        const base64Data = e.target.result.split(",")[1];
        hiddenInput.value = base64Data;
        previewImage.src = e.target.result;
        previewImage.style.display = "inline";
        config[field.id] = base64Data;
        updateConfigAndPreview();
      };
      reader.readAsDataURL(file);
    });

    return container;
  }

  function createTypeaheadField(field, config) {
    let inputElement = document.createElement("div");

    const typeaheadInput = document.createElement("input");
    typeaheadInput.type = "text";
    typeaheadInput.id = `${field.id}_typeahead`;
    typeaheadInput.setAttribute("data-ignore-config", "true");
    typeaheadInput.placeholder = "{{ t .Localizer "Start typing..." }}";
    typeaheadInput.className = "field-input";
    inputElement.appendChild(typeaheadInput);

    const hiddenTypeaheadInput = document.createElement("input");
    hiddenTypeaheadInput.type = "hidden";
    hiddenTypeaheadInput.id = "schema_" + field.id;
    hiddenTypeaheadInput.dataset.configId = field.id;
    hiddenTypeaheadInput.name = field.id;
    hiddenTypeaheadInput.value = JSON.stringify(config[field.id] || {});
    inputElement.appendChild(hiddenTypeaheadInput);

    const typeaheadResults = document.createElement("ul");
    typeaheadResults.id = `${field.id}_results`;
    typeaheadResults.style.listStyleType = "none";
    typeaheadResults.style.padding = "0";
    typeaheadResults.style.margin = "0";
    typeaheadResults.style.border = "1px solid #ccc";
    typeaheadResults.style.maxHeight = "150px";
    typeaheadResults.style.overflowY = "auto";
    typeaheadResults.style.display = "none";
    inputElement.appendChild(typeaheadResults);

    typeaheadInput.addEventListener("input", async function () {
      const query = typeaheadInput.value.trim();
      if (!query) {
        typeaheadResults.style.display = "none";
        typeaheadResults.innerHTML = "";
        return;
      }

      try {
        const handlerUrl = "/devices/{{ .Device.ID }}/{{ .App.Iname }}/schema_handler/" + field.handler;
        const response = await fetch(handlerUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ id: field.id, param: query, config: config })
        });

        if (!response.ok) throw new Error("Failed to fetch typeahead options");

        const options = await response.json();
        typeaheadResults.innerHTML = "";

        options.forEach(option => {
          const listItem = document.createElement("li");
          listItem.textContent = option.display;
          listItem.style.cursor = "pointer";
          listItem.style.padding = "5px";
          listItem.addEventListener("click", () => {
            typeaheadInput.value = option.display;
            hiddenTypeaheadInput.value = JSON.stringify(option);
            typeaheadResults.style.display = "none";
            typeaheadResults.innerHTML = "";
            config[field.id] = option;
            updateConfigAndPreview();
          });
          typeaheadResults.appendChild(listItem);
        });
        typeaheadResults.style.display = "block";
      } catch (error) {
        console.error("Error fetching typeahead options:", error);
      }
    });

    document.addEventListener("click", function (event) {
      if (!inputElement.contains(event.target)) {
        typeaheadResults.style.display = "none";
      }
    });
    return inputElement;
  }

  function createGeneratedField(field, config) {
    const sourceField = document.getElementById("schema_" + field.source);
    if (!sourceField) {
      console.warn(`Source field with id "schema_${field.source}" not found for generated field "${field.id}"`);
      return;
    }

    const updateGeneratedFields = async () => {
      let sourceValue = sourceField.value;
      if (sourceField.type === "checkbox") {
        sourceValue = sourceField.checked ? "true" : "false";
      }
      try {
        const handlerUrl = "/devices/{{ .Device.ID }}/{{ .App.Iname }}/schema_handler/" + field.handler;
        const response = await fetch(handlerUrl, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ id: field.id, param: sourceValue, config: config })
        });

        if (!response.ok) throw new Error("Failed to fetch generated fields");

        const generatedFields = await response.json();

        // Clear existing rows
        const existingRows = document.querySelectorAll(`[data-generated-field="${field.id}"]`);
        existingRows.forEach(row => row.remove());

        // Note: generatedFields is a full schema object with a 'schema' array
        const generatedInput = createFormFields(generatedFields, config);
        const formTable = document.getElementById("schemaConfigContainer");
        generatedInput.forEach(row => {
          row.setAttribute("data-generated-field", field.id);
          formTable.appendChild(row);
        });
      } catch (error) {
        console.error("Error fetching generated fields:", error);
      }
    };

    // Need to bind to correct event
    const eventType = (sourceField.type === 'checkbox' || sourceField.tagName === 'SELECT') ? 'change' : 'input';
    sourceField.addEventListener(eventType, updateGeneratedFields);

    updateGeneratedFields();
  }

  function createColorPaletteButtons(field, inputElement) {
    const hexColorRegex = /^#([0-9a-f]{3}){1,2}$/i;
    const div = document.createElement('div');
    div.className = 'palette';
    if(field.palette) {
        field.palette.forEach(color => {
            if (!hexColorRegex.test(color)) return;
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'w3-button';
            btn.style.setProperty('--color', color);
            btn.style.backgroundColor = color; // Fallback
            btn.style.width = '20px';
            btn.style.height = '20px';
            btn.style.margin = '2px';
            btn.addEventListener('click', () => {
                if (color.length === 4) {
                    color = '#' + [...color.slice(1)].map(c => c + c).join('');
                }
                inputElement.value = color;
                inputElement.dispatchEvent(new Event('input'));
            })
            div.appendChild(btn);
        });
    }
    return div;
  }

  async function fetchOptionsForLocation(field, locationQueryJson, dropdown, currentOptionJsonString) {
    try {
      const handlerUrl = "/devices/{{ .Device.ID }}/{{ .App.Iname }}/schema_handler/" + field.handler;
      const response = await fetch(handlerUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id: field.id, param: locationQueryJson, config: config })
      });

      if (!response.ok) throw new Error("Failed to fetch options");

      const options = await response.json();
      dropdown.innerHTML = "";

      let selectedIndex = 0;
      let currentOptionFromConfig = null;

      if (typeof currentOptionJsonString === 'string' && currentOptionJsonString !== 'undefined') {
        try {
          currentOptionFromConfig = JSON.parse(currentOptionJsonString);
        } catch (e) {
          // ignore
        }
      }

      if (options && options.length > 0) {
        options.forEach((option, index) => {
          const opt = document.createElement("option");
          opt.value = JSON.stringify(option);
          opt.textContent = option.display;
          dropdown.appendChild(opt);

          if (currentOptionFromConfig && JSON.stringify(option) === JSON.stringify(currentOptionFromConfig)) {
            selectedIndex = index;
          }
        });
        dropdown.selectedIndex = selectedIndex;
      } else {
        const noOpt = document.createElement("option");
        noOpt.textContent = "{{ t .Localizer "No options available for this location" }}";
        noOpt.value = "";
        noOpt.disabled = true;
        dropdown.appendChild(noOpt);
      }
      dropdown.dispatchEvent(new Event("change"));
    } catch (error) {
      console.error(`Error fetching options for field ${field.id}:`, error);
      dropdown.innerHTML = "";
      const errOpt = document.createElement("option");
      errOpt.textContent = "{{ t .Localizer "Error loading options" }}";
      errOpt.value = "";
      errOpt.disabled = true;
      dropdown.appendChild(errOpt);
    }
  }

  // Recurrence Logic
  function initializeRecurrenceOptions() {
    toggleCustomRecurrence();

    const monthlyPatternSelect = document.getElementById("monthly_pattern");
    if (monthlyPatternSelect) {
      monthlyPatternSelect.addEventListener("change", toggleMonthlyPatternOptions);
      toggleMonthlyPatternOptions();
    }

    const weekOccurrenceSelect = document.getElementById("week_occurrence");
    const weekDaySelect = document.getElementById("week_day");
    if (weekOccurrenceSelect && weekDaySelect) {
      weekOccurrenceSelect.addEventListener("change", updateDayOfWeekPattern);
      weekDaySelect.addEventListener("change", updateDayOfWeekPattern);

      // Initialize if value exists
      const hiddenPattern = document.getElementById("day_of_week_pattern");
      if(hiddenPattern && hiddenPattern.value) {
          const parts = hiddenPattern.value.split('_');
          if(parts.length === 2) {
              weekOccurrenceSelect.value = parts[0];
              weekDaySelect.value = parts[1];
          }
      }
      updateDayOfWeekPattern();
    }
  }

  function toggleCustomRecurrence() {
    const useCustom = document.getElementById("use_custom_recurrence").checked;
    const legacySchedule = document.getElementById("legacy_schedule");
    const customRecurrence = document.getElementById("custom_recurrence");

    if (useCustom) {
      legacySchedule.classList.add("hidden");
      customRecurrence.classList.remove("hidden");
      toggleRecurrenceOptions();
    } else {
      legacySchedule.classList.remove("hidden");
      customRecurrence.classList.add("hidden");
    }
  }

  function toggleRecurrenceOptions() {
    const type = document.getElementById("recurrence_type").value;
    const weeklyOptions = document.getElementById("weekly_options");
    const monthlyOptions = document.getElementById("monthly_options");
    const intervalUnit = document.getElementById("interval_unit");

    // Hide all first
    weeklyOptions.classList.add("hidden");
    monthlyOptions.classList.add("hidden");

    // Show relevant one
    if (type === 'weekly') weeklyOptions.classList.remove("hidden");
    if (type === 'monthly') monthlyOptions.classList.remove("hidden");

    switch (type) {
      case "daily": intervalUnit.textContent = "{{ t .Localizer "days" }}"; break;
      case "weekly": intervalUnit.textContent = "{{ t .Localizer "weeks" }}"; break;
      case "monthly": intervalUnit.textContent = "{{ t .Localizer "months" }}"; break;
      case "yearly": intervalUnit.textContent = "{{ t .Localizer "years" }}"; break;
    }
  }

  function toggleMonthlyPatternOptions() {
    const monthlyPattern = document.getElementById("monthly_pattern").value;
    const dayOfMonthOption = document.getElementById("day_of_month_option");
    const dayOfWeekOption = document.getElementById("day_of_week_option");

    if (monthlyPattern === "day_of_month") {
      dayOfMonthOption.classList.remove("hidden");
      dayOfWeekOption.classList.add("hidden");
    } else {
      dayOfMonthOption.classList.add("hidden");
      dayOfWeekOption.classList.remove("hidden");
    }
  }

  function updateDayOfWeekPattern() {
    const occurrence = document.getElementById("week_occurrence").value;
    const day = document.getElementById("week_day").value;
    const hiddenField = document.getElementById("day_of_week_pattern");

    if (occurrence && day) {
      hiddenField.value = occurrence + "_" + day;
    }
  }

  function collectSettings() {
      const days = Array.from(document.querySelectorAll('input[name="days"]:checked')).map(cb => cb.value);
      const weekdays = Array.from(document.querySelectorAll('input[name="weekdays"]:checked')).map(cb => cb.value);

      // Collect settings
      const settings = {
          enabled: document.getElementById('enabled').checked,
          autopin: document.getElementById('autopin').checked,
          uinterval: parseInt(document.getElementById('uinterval').value),
          display_time: parseInt(document.getElementById('display_time').value),
          notes: document.getElementById('notes').value,
          start_time: document.getElementById('start_time').value,
          end_time: document.getElementById('end_time').value,
          color_filter: document.getElementById('color_filter').value,
          days: days,

          use_custom_recurrence: document.getElementById('use_custom_recurrence').checked,
          recurrence_type: document.getElementById('recurrence_type').value,
          recurrence_interval: parseInt(document.getElementById('recurrence_interval').value),
          recurrence_start_date: document.getElementById('recurrence_start_date').value,
          recurrence_end_date: document.getElementById('recurrence_end_date').value,
          weekdays: weekdays,

          // Monthly pattern construction
          monthly_pattern: document.getElementById('monthly_pattern') ? document.getElementById('monthly_pattern').value : null,
          day_of_month: document.getElementById('day_of_month') ? parseInt(document.getElementById('day_of_month').value) : null,
          day_of_week_pattern: document.getElementById('day_of_week_pattern') ? document.getElementById('day_of_week_pattern').value : null,

          config: config
      };

      // Construct recurrence_pattern object
      if (settings.use_custom_recurrence) {
         settings.recurrence_pattern = {};
         if (settings.recurrence_type === 'weekly') {
             settings.recurrence_pattern.weekdays = weekdays;
         } else if (settings.recurrence_type === 'monthly') {
             if (settings.monthly_pattern === 'day_of_month') {
                 settings.recurrence_pattern.day_of_month = settings.day_of_month;
             } else {
                 settings.recurrence_pattern.day_of_week = settings.day_of_week_pattern;
             }
         }
      }
      return settings;
  }

  function exportConfig() {
      const settings = collectSettings();
      const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(settings, null, 2));
      const downloadAnchorNode = document.createElement('a');
      downloadAnchorNode.setAttribute("href", dataStr);
      downloadAnchorNode.setAttribute("download", "app_config_{{ .App.Iname }}.json");
      document.body.appendChild(downloadAnchorNode); // required for firefox
      downloadAnchorNode.click();
      downloadAnchorNode.remove();
  }

  function importConfig(input) {
      const file = input.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
          try {
              const settings = JSON.parse(e.target.result);

              // Field Mappings for simple values and checkboxes
              const fieldMappings = {
                  enabled: { type: 'checked' },
                  autopin: { type: 'checked' },
                  uinterval: { type: 'value', default: '' },
                  display_time: { type: 'value', default: '' },
                  notes: { type: 'value', default: '' },
                  start_time: { type: 'value', default: '' },
                  end_time: { type: 'value', default: '' },
                  color_filter: { type: 'value', default: 'inherit' },
                  use_custom_recurrence: { type: 'checked' },
                  recurrence_type: { type: 'value', default: 'daily' },
                  recurrence_interval: { type: 'value', default: '1' },
                  recurrence_start_date: { type: 'value', default: '' },
                  recurrence_end_date: { type: 'value', default: '' },
              };

              // Apply standard mappings
              for (const [key, config] of Object.entries(fieldMappings)) {
                  const element = document.getElementById(key);
                  if (element) {
                      if (config.type === 'checked') {
                          element.checked = !!settings[key];
                      } else {
                          element.value = settings[key] ?? config.default;
                      }
                  }
              }

              // Days
              document.querySelectorAll('input[name="days"]').forEach(cb => {
                  cb.checked = Array.isArray(settings.days) && settings.days.includes(cb.value);
              });

              // Toggle Recurrence UI based on imported values
              toggleCustomRecurrence();
              toggleRecurrenceOptions();

              // Weekdays
              document.querySelectorAll('input[name="weekdays"]').forEach(cb => {
                  cb.checked = Array.isArray(settings.weekdays) && settings.weekdays.includes(cb.value);
              });

              // Monthly pattern
              if (settings.monthly_pattern) {
                  const el = document.getElementById('monthly_pattern');
                  if (el) {
                      el.value = settings.monthly_pattern;
                      toggleMonthlyPatternOptions();
                  }
              }

              const domEl = document.getElementById('day_of_month');
              if (domEl) domEl.value = settings.day_of_month ?? '';

              if (settings.day_of_week_pattern) {
                  const parts = settings.day_of_week_pattern.split('_');
                  if (parts.length === 2) {
                      const occEl = document.getElementById('week_occurrence');
                      const dayEl = document.getElementById('week_day');
                      if (occEl) occEl.value = parts[0];
                      if (dayEl) dayEl.value = parts[1];
                      updateDayOfWeekPattern();
                  }
              }

              // Config object - Update global config object and UI
              if (settings.config && typeof settings.config === 'object') {
                  Object.assign(config, settings.config);

                  // Update UI fields
                  for (const [key, value] of Object.entries(settings.config)) {
                      // Handle potential nulls in config object
                      const safeValue = value ?? '';
                      const input = document.querySelector(`[data-config-id="${key}"]`);
                      if (input) {
                          if (input.type === 'checkbox') {
                              input.checked = safeValue === 'true' || safeValue === true;
                          } else {
                              input.value = safeValue;
                          }
                          // Trigger change event for dependent fields (like generated fields)
                          input.dispatchEvent(new Event('change'));
                          input.dispatchEvent(new Event('input'));
                      }
                  }
              }

              updateConfigAndPreview();
              alert("{{ t .Localizer "Config imported successfully. Click Save to apply changes." }}");

          } catch (err) {
              console.error(err);
              alert("{{ t .Localizer "Error parsing config file." }}");
          }
          // Reset input
          input.value = '';
      };
      reader.readAsText(file);
  }

  function deleteApp(deviceId, iname, deleteOnCancel) {
      fetch(`/devices/${deviceId}/${iname}/delete`, {
        method: 'POST'
      }).then(() => {
           window.location.href = "/";
      }).catch(() => {
        alert("{{ t .Localizer "Error deleting app." }}");
        window.location.href = "/";
      });
  }

  document.addEventListener("DOMContentLoaded", function () {
    const previewImage = document.getElementById('previewImage');
    if (previewImage) {
        previewImage.addEventListener('load', () => {
            previewImage.classList.add('loaded');
        });
        // Handle cached images
        if (previewImage.complete) {
            previewImage.classList.add('loaded');
        }
    }

    const form = document.getElementById("dynamicForm");
    const formTable = document.getElementById("schemaConfigContainer");

    // Generate schema fields
    const formFields = createFormFields(schema, config);
    formFields.forEach(row => {
      formTable.appendChild(row);
    });

    // Create generated fields
    createGeneratedFormFields(schema, config);

    initializeToggleButtons();
    initializeRecurrenceOptions();
    updateConfigAndPreview();

    form.addEventListener("submit", function (event) {
      event.preventDefault();

      const settings = collectSettings();

      fetch(window.location.href, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(settings),
      }).then(response => {
        if (response.ok) {
          window.location.href = "/";
        } else {
          alert("Error saving config");
        }
      });
    });

    // Preview Button logic
    const previewButton = document.getElementById("previewButton");
    if(previewButton) {
        previewButton.addEventListener("click", (event) => {
            previewApp('{{ .Device.ID }}', '{{ .App.Iname }}', config, event.currentTarget, { previewing: '{{ t .Localizer "Previewing..." }}', sent: '{{ t .Localizer "Sent" }}', failed: '{{ t .Localizer "Failed" }}' })
            .then(() => {
                 // Refresh image with cache busting
                 const img = document.getElementById("previewImage");
                 if(img) img.src = img.src.split('?')[0] + '?t=' + new Date().getTime();
            });
        });
    }

    // Cancel buttons
    const cancelButton = document.getElementById("cancelButton");
    if (cancelButton) cancelButton.addEventListener("click", () => {
        if (deleteOnCancel) {
            deleteApp('{{ .Device.ID }}', '{{ .App.Iname }}', true);
        } else {
            window.location.href = "/";
        }
    });
    const cancelButtonTop = document.getElementById("cancelButtonTop");
    if (cancelButtonTop) cancelButtonTop.addEventListener("click", () => {
        if (deleteOnCancel) {
            deleteApp('{{ .Device.ID }}', '{{ .App.Iname }}', true);
        } else {
            window.location.href = "/";
        }
    });
  });
</script>
{{ end }}
